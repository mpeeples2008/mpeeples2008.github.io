<!DOCTYPE html>
<html lang="en">

<head>

<!-- Simple SfxManager shim inserted to replace complex monkeypatching -->
<script>
/* Simple, safe SfxManager for local testing and reliability */
window.SfxManager = (function(){
  const S = {
    installed: false,
    volume: 0.6,
    enabled: true,
    // Play a small audio via HTMLAudioElement; swallow errors
    play: function(url){
      if (!this.enabled || !url) return;
      try {
        // Avoid attempting to load file:// resources for local testing
        if (location && location.protocol === 'file:' && url.startsWith('/')) {
          // skip attempting to fetch absolute local paths
          return;
        }
        const a = new Audio(url);
        a.volume = this.volume;
        const p = a.play();
        if (p && typeof p.catch === 'function') p.catch(()=>{});
      } catch(e) {
      }
    },
    preload: function(urls){
      if (!Array.isArray(urls)) return;
      if (location && location.protocol === 'file:') return; // skip preloading on file://
      try {
        urls.forEach(u=>{
          try { fetch(u, {mode:'no-cors'}).catch(()=>{}); } catch(e){}
        });
      } catch(e){}
    },
    install: function(){ this.installed = true; },
    setVolume: function(v){ this.volume = Number(v) || 0.6; },
  };
  return S;
})();
</script>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta property="og:image" content="https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/social_media.png" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="640" />
    <meta property="og:image:height" content="320" />


    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <title>Gone Viral!</title>

    <link rel="preload" href="https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/PressStart2P-Regular.woff2" as="font" type="font/woff2" crossorigin>

    

    


    


    <!-- AUDIO POPUP CSS INSERTED BY CHATGPT -->
    
    <!-- END AUDIO POPUP CSS -->
    <!-- Assistant: force wrap-anchored layout + correct image sizing -->
    


    <!-- START-MISSION modal CSS -->
    
    <!-- END START-MISSION modal CSS -->


    


    


    <!-- Consolidated CSS overrides added by assistant -->
    
    <!-- End consolidated CSS overrides -->
    <!-- Assistant: breathe and hue animations -->
    <!-- End Assistant breathe/hue -->
    <!-- Assistant: breathe-only animation -->
    

    <script id="assistant-breathe-only-script">
        document.addEventListener('DOMContentLoaded', function () {
            function assign(el) {
                const d = (Math.random() * 1.2) - 0.6;
                el.style.animationDelay = d.toFixed(2) + 's';
                if (el.closest('.virus--size-0')) el.style.setProperty('--breathe-duration', (5.5 + Math.random() * 0.6).toFixed(2) + 's');
                if (el.closest('.virus--size-1')) el.style.setProperty('--breathe-duration', (4.0 + Math.random() * 0.5).toFixed(2) + 's');
                if (el.closest('.virus--size-2')) el.style.setProperty('--breathe-duration', (3.2 + Math.random() * 0.4).toFixed(2) + 's');
            }
            const elems = document.querySelectorAll('.virus--size-0 .face-sprite, .virus--size-1 .face-sprite, .virus--size-2 .face-sprite');
            elems.forEach(assign);
            const board = document.querySelector('#board');
            if (board && window.MutationObserver) {
                const mo = new MutationObserver(muts => {
                    muts.forEach(m => {
                        m.addedNodes.forEach(node => {
                            if (!node || node.nodeType !== 1) return;
                            const faces = node.querySelectorAll && node.querySelectorAll('.face-sprite');
                            if (faces && faces.length) { faces.forEach(assign); }
                            if (node.classList && node.classList.contains('face-sprite')) assign(node);
                        });
                    });
                });
                mo.observe(board, { childList: true, subtree: true });
            }
        });
    </script>
    <!-- End Assistant breathe-only animation -->




<style>
/* Consolidated CSS - grouped by purpose (blocks preserved) */

/* Modals */

@font-face {
            font-family: 'Press Start 2P';
            src: url('https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/PressStart2P-Regular.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        :root {
            --board-size: 720px
        }

        html,
        body {
            height: 100%;
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
            /* full-page background image, fixed centered - made to work in both narrow and wide configurations */
            background: linear-gradient(rgba(0, 0, 0, 0.45), rgba(0, 0, 0, 0.45)), url('https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/lab.png') center center / cover no-repeat fixed;
            color: #0b3d91;
        }

        /* Make wrap and board semi-transparent so background shows through
        Layout behavior:
        - Default (mobile / narrow): vertical stack — board above, hud spans full width at bottom.
        - Wide screens (min-width:900px): horizontal layout — board on left, hud fixed-width column on right. */
        .wrap {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.18);
            border-radius: 12px;
            position: relative;
            z-index: 2;
            width: 100%;
            box-sizing: border-box;
            max-width: 1200px;
            margin: 0 auto;
        }

        .board {
            width: min(var(--board-size), 94vw);
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.22);
            border-radius: 12px;
            padding: 0;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-auto-rows: 1fr;
            gap: 0;
            box-sizing: border-box
        }

        /* HUD styling — responsive: full-width on narrow, right-column on wide, test on mobile and browser */
        .hud {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.04));
            border-radius: 12px;
            padding: 8px;
            width: 100%;
            box-sizing: border-box;
            border: 4px solid rgba(0, 0, 0, 0.25);
            box-shadow: 8px 8px 0 rgba(0, 0, 0, 0.12), -6px -6px 0 rgba(255, 255, 255, 0.02);
            font-family: 'Press Start 2P', monospace;
            color: #ffd166;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.55);
        }

        /* Unified Score + High Score box, fully left-justified */
        .small.scorebox {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            /* stop flex centering */
            text-align: left !important;
            /* override .small center alignment */
            line-height: 1.2;
            width: 100%;
            /* ensures text uses full box width */
        }

            .small.scorebox .score-line,
            .small.scorebox .high-line {
                width: 100%;
                text-align: left !important;
                /* force left alignment inside */
            }

            .small.scorebox .score-line {
                font-size: 9px;
                color: #ffd166;
            }

            .small.scorebox .high-line {
                font-size: 8px;
                opacity: 0.85;
                color: #ffe9b0;
                margin-top: 2px;
                text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.55);
            }

                .small.scorebox .high-line span#highScoreValue {
                    font-size: inherit;
                }

        .level-box {
            font-size: 9px;
            /* or whatever size you want */
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.04));
            border-radius: 12px;
            padding: 8px;
            width: 50%;
            box-sizing: border-box;
            border: 4px solid rgba(0, 0, 0, 0.25);
            box-shadow: 8px 8px 0 rgba(0, 0, 0, 0.12), -6px -6px 0 rgba(255, 255, 255, 0.02);
            font-family: 'Press Start 2P', monospace;
            color: #ffd166;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.55);
        }


        /* On wide screens place HUD to the right at a fixed column width */
        @media (min-width: 900px) {
            .wrap {
                flex-direction: row;
                align-items: flex-start;
                justify-content: center;
                gap: 20px;
                padding: 20px
            }

            .board {
                order: 1;
                width: calc(min(var(--board-size), 74vw));
                max-width: calc(100% - 300px)
            }

            .hud {
                order: 2;
                width: 300px;
                flex-direction: column;
                align-items: flex-start;
                justify-content: flex-start;
                padding: 18px 14px
            }

                .hud .small {
                    align-self: stretch
                }

                .hud button {
                    width: 100%
                }
        }

        /* cell property style */
        .cell {
            background: transparent;
            border-radius: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            overflow: visible;
            padding: 0;
            box-sizing: content-box;
            width: 100%;
            height: 100%
        }

        /* virus property sytle */
        .virus {
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
            box-sizing: content-box
        }

        /* Petri dish on each cell - property style */
        .petri {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(1.2);
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            /* experimental */
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: center center
        }

            .petri img {
                width: 100%;
                height: 100%;
                object-fit: contain;
                display: block;
                opacity: 1
            }

        /* virus face sprite: single centered image, only scaling changes */
        .face-sprite {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: visible;
            z-index: 3;
            pointer-events: none;
            /* experimental */
            transform-origin: center center;
            display: flex;
            align-items: center;
            justify-content: center
        }

            .face-sprite img {
                width: 100%;
                height: 100%;
                object-fit: contain;
                pointer-events: none;
                transform-origin: center center;
                display: block
            }

        /* Animate size-3 viruses with gentle jitter/pulse - make it look like it's ready to burst! */
        @keyframes jitter {

            0%, 100% {
                transform: scale(1) translate(0, 0);
            }

            25% {
                transform: scale(1.03) translate(1px, -1px);
            }

            50% {
                transform: scale(0.97) translate(-1px, 1px);
            }

            75% {
                transform: scale(1.02) translate(-1px, -1px);
            }
        }

        .virus--size-3 .face-sprite img {
            animation: jitter 0.45s infinite ease-in-out;
        }

        /* Animate the splat/stain/burst when a virus pops */
        .stain {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 28% 28%, rgba(110, 200, 40, 0.44), rgba(30, 100, 20, 0.24));
            pointer-events: none;
            opacity: 0;
            z-index: 4
        }

            .stain.show {
                animation: stainpop 520ms forwards
            }

        @keyframes stainpop {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0.95
            }

            50% {
                transform: translate(-50%, -50%) scale(1.08);
                opacity: 0.7
            }

            100% {
                transform: translate(-50%, -50%) scale(1.8);
                opacity: 0
            }
        }

        /* --- SPRITE-BASED PARTICLES + randomized rotation support --- */
        .particle {
            position: fixed;
            z-index: 30000;
            width: 35px;
            /* small size as default */
            height: 35px;
            pointer-events: none;
            transform-origin: center center;
            transform: translate3d(0px, 0px, 0) translate(-50%, -50%) scale(1.5);
            opacity: 1;
            display: block;
            filter: drop-shadow(0 4px 10px rgba(120, 40, 160, 0.12));
            will-change: transform, opacity;
            transition: transform 520ms cubic-bezier(.2, .8, .2, 1), opacity 300ms linear;
        }

            /* particle contains an <img> (raster sprite) */
            .particle > img {
                width: 100%;
                height: 100%;
                display: block;
                pointer-events: none;
                user-select: none;
                -webkit-user-drag: none;
            }


        /* HUD child elements: retro 'panels' for each stat */
        .hud .small {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(255, 255, 255, 0.02));
            padding: 10px 12px;
            border-radius: 8px;
            border: 4px solid rgba(0, 0, 0, 0.25);
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.12);
            min-width: 85px;
            color: #ffd166;
            font-family: 'Press Start 2P', monospace;
            font-size: 11px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.55);
        }

        .hud-row {
            display: flex;
            flex-direction: row;
            gap: 12px;
            /* spacing between Level and Score */
            align-items: center;
        }

        /* Make HUD buttons match retro badge look */
        .hud button {
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(180deg, #ffffff, #e6e3ff);
            color: #0b3d91;
            border: 4px solid rgba(0, 0, 0, 0.18);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.12);
            cursor: pointer;
            font-size: 11px;
        }

        /* small screens tweak */
        @media (max-width:420px) {
            .board {
                width: 94vw
            }

            .hud .small {
                min-width: 90px;
                padding: 8px;
                font-size: 10px
            }
        }

        /* glowing burst at pop */
        .glow {
            position: fixed;
            z-index: 25000;
            pointer-events: none;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            filter: blur(10px);
            opacity: 0.95;
            background: radial-gradient(circle at 35% 30%, rgba(157, 0, 255, 0.95), rgba(130, 0, 150, 0.6) 40%, rgba(255, 90, 20, 0.15) 70%);
        }

        @keyframes glowPop {
            0% {
                transform: translate(-50%, -50%) scale(0.2);
                opacity: 0.95
            }

            30% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 0.9
            }

            70% {
                transform: translate(-50%, -50%) scale(1.6);
                opacity: 0.45
            }

            100% {
                transform: translate(-50%, -50%) scale(2.4);
                opacity: 0
            }
        }

        /* Badge UI — retro styling using Press Start 2P */
        .chain-badge {
            position: fixed;
            left: 50%;
            top: 12%;
            transform: translateX(-50%) translateY(-6px) scale(0.85);
            z-index: 40000;
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(180deg, #0b3d91, #08306a);
            /* default deep-blue base for retro look */
            color: #ffd166;
            /* warm pixel color for text */
            padding: 10px 18px;
            border-radius: 8px;
            border: 4px solid rgba(0, 0, 0, 0.45);
            /* thick pixel-like border */
            font-weight: 400;
            font-size: 14px;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 0;
            will-change: transform, opacity;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.65), 4px 4px 0 rgba(0, 0, 0, 0.45);
            /* chunky pixel shadow */
        }

            .chain-badge .cb-icon {
                width: 44px;
                height: 36px;
                border-radius: 6px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
                background: rgba(0, 0, 0, 0.18);
                box-shadow: inset -6px -6px 0 rgba(0, 0, 0, 0.12), inset 6px 6px 0 rgba(255, 255, 255, 0.02);
            }

        @keyframes badgeIn {
            0% {
                transform: translateX(-50%) translateY(6px) scale(0.7);
                opacity: 0;
            }

            50% {
                transform: translateX(-50%) translateY(-6px) scale(1.05);
                opacity: 1;
            }

            100% {
                transform: translateX(-50%) translateY(-18px) scale(1);
                opacity: 1;
            }
        }

        @keyframes badgeOut {
            0% {
                opacity: 1;
                transform: translateX(-50%) translateY(-18px) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-28px) scale(0.9);
            }
        }

        .chain-badge.show {
            animation: badgeIn 360ms steps(2, end) forwards;
        }

        .chain-badge.hide {
            animation: badgeOut 360ms ease forwards;
        }

        /* Retro color variants inspired by the attached image. These keep the pixel aesthetic while providing variety. */
        .chain-badge.great {
            background: linear-gradient(180deg, #0b5ea8, #083b6b);
            color: #ffd166;
            border-color: rgba(0, 0, 0, 0.6);
        }

        .chain-badge.amazing {
            background: linear-gradient(180deg, #b33b2b, #8a1f14);
            color: #ffd166;
            border-color: rgba(0, 0, 0, 0.6);
        }

        .chain-badge.stupendous {
            background: linear-gradient(180deg, #8a1f14, #6a0f0f);
            color: #ffd166;
            border-color: rgba(0, 0, 0, 0.6);
        }

        .chain-badge.incredible {
            background: linear-gradient(180deg, #5b2b86, #381a5a);
            color: #ffd166;
            border-color: rgba(0, 0, 0, 0.6);
        }

            /* pixel 'bevel' effect by adding layered box-shadows — subtle and GPU-friendly */
            .chain-badge.great .cb-icon,
            .chain-badge.amazing .cb-icon,
            .chain-badge.stupendous .cb-icon,
            .chain-badge.incredible .cb-icon {
                box-shadow: inset -6px -6px 0 rgba(0, 0, 0, 0.12), 6px 6px 0 rgba(0, 0, 0, 0.12);
            }

        /* small responsive adjustment so badges aren't huge on mobile */
        @media (max-width: 420px) {
            .chain-badge {
                font-size: 11px;
                padding: 8px 12px;
            }

                .chain-badge .cb-icon {
                    width: 34px;
                    height: 28px;
                    font-size: 14px
                }
        }

        /* container base (if you already have .level-complete, don't duplicate; merge the .visible transition bits) */
        .level-complete {
            position: fixed; /* likely you already use fixed/absolute; keep as needed */
            left: 50%;
            top: 50%; /* tweak vertical position to taste */
            transform: translate(-50%, -50%);
            width: min(90vw, 900px);
            max-width: 100% fit-content 10px);
            max-height: 92vh;
            box-sizing: border-box;
            z-index: 9999;
            padding: 12px 14px;
            border-radius: 10px;
            background: rgba(0,0,0,0.86);
            color: #fff;
            text-align: center;
            box-shadow: 0 8px 30px rgba(0,0,0,0.45);
            opacity: 0;
            overflow: hidden;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 12px;
            transition: opacity .28s ease, transform .28s ease;
            
        }

            /* visible state */
            .level-complete.visible {
                opacity: 1;
                pointer-events: auto;
                transform: translateX(-50%) translateY(0);
            }

            /* title */
            .level-complete .lc-title {
                font-weight: 700;
                font-family: 'Press Start 2P', monospace;
                font-size: 20px;
                line-height: 1;
            }

            /* image container placed AFTER title (user requested) */
            .level-complete .lc-image {
                flex: 0 0 auto;
                display: block;
                width: 100%;
                text-align: center;
            }

                /* the image itself: constrain to max-width: 360px but be responsive */
                .level-complete .lc-image img {
                    display: block;
                    width: 100%;
                    max-width: 900px; /* your requested maximum width */
                    height: auto;
                    max-height: calc(72vh - 120px);
                    object-fit: contain; /* preserve aspect, center contents if needed */
                    border-radius: 6px; /* optional */
                    user-select: none;
                    pointer-events: none;
                }

        /* tweak for small screens so it doesn't look huge */
        @media (max-width: 600px) {
            .level-complete .lc-title {
                font-size: 18px;
                word-break: break-word;
            }

            .level-complete .lc-image img {
                max-height: calc(78vh - 100px);
            }

            F
        }


        /* ---------- Game Over popup ---------- */
        .game-over-popup {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            z-index: 95000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 10px;
            padding: 30px 40px;
            border-radius: 14px;
            border: 6px solid rgba(0, 0, 0, 0.55);
            background: linear-gradient(180deg, #8a1f14, #6a0f0f);
            color: #ffd166;
            box-shadow: 8px 8px 0 rgba(0, 0, 0, 0.3);
            font-family: 'Press Start 2P', monospace;
            font-size: 20px;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            will-change: transform, opacity;
        }

            /* Inner title and subtitle */
            .game-over-popup .go-title {
                font-size: 24px;
                text-transform: uppercase;
                text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.6);
                letter-spacing: 0.04em;
            }

            .game-over-popup .go-sub {
                font-size: 14px;
                color: #ffe9b0;
                text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.6);
            }

        @keyframes gameOverIn {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }

            60% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.05);
            }

            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes gameOverOut {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.95);
            }
        }

        .game-over-popup.show {
            animation: gameOverIn 400ms ease both;
        }

        .game-over-popup.hide {
            animation: gameOverOut 400ms ease forwards;
        }

        /* Inner title larger and tightly tracked */
        .level-complete .lc-title {
            font-size: 20px;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.6);
        }

        /* subtle icon slot (optional) */
        .level-complete .lc-icon {
            width: 56px;
            height: 56px;
            flex: 0 0 auto;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.12);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset -6px -6px 0 rgba(0, 0, 0, 0.12);
        }

        /* Animations */
        @keyframes levelIn {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8) rotate(-6deg);
            }

            60% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.03) rotate(2deg);
            }

            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
            }
        }

        @keyframes levelOut {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.92);
            }
        }

        /* helper classes to control lifecycle */
        .level-complete.show {
            animation: levelIn 420ms cubic-bezier(.2, .9, .2, 1) both;
            pointer-events: none;
        }

        .level-complete.hide {
            animation: levelOut 360ms ease forwards;
            pointer-events: none;
        }

        /* Small fixed mute button at bottom-right */
        .bottom-mute {
            position: fixed;
            right: 12px;
            bottom: 12px;
            z-index: 60000;
            padding: 8px 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            border-radius: 8px;
            border: 3px solid rgba(0, 0, 0, 0.18);
            background: linear-gradient(180deg, #ffffff, #e6e3ff);
            color: #0b3d91;
            box-shadow: 3px 3px 0 rgba(0, 0, 0, 0.12);
        }

        .bottom-controls {
            position: fixed;
            right: 12px;
            bottom: 12px;
            z-index: 60000;
            display: flex;
            flex-direction: row;
            gap: 8px;
            /* space between buttons */
        }

            .bottom-controls .bottom-mute {
                position: static;
                /* remove the fixed positioning */
            }

        /* Meter styles (10-segment retro pixel bar) */
        .meter {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            border-radius: 8px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.06), rgba(255, 255, 255, 0.02));
            border: 4px solid rgba(0, 0, 0, 0.25);
            min-width: 140px
        }

        .meter-icon {
            flex: 0 0 auto
        }

        .meter-segments {
            display: flex;
            gap: 2px;
            align-items: center;
            justify-content: center
        }

            .meter-segments .seg {
                width: 12px;
                height: 12px;
                border: 2px solid #081426;
                background: #2b2b2b;
                box-shadow: inset -3px -3px 0 rgba(0, 0, 0, 0.18);
                border-radius: 1px
            }

                .meter-segments .seg.filled {
                    background: linear-gradient(180deg, #ffd166, #ffb84d);
                    border-color: #081426;
                    box-shadow: inset -5px -5px 0 rgba(0, 0, 0, 0.18)
                }

        .meter-count {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #ffd166;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.55)
        }

        .seg.pop {
            animation: segPop 220ms ease both
        }

        @keyframes segPop {
            0% {
                transform: scale(1)
            }

            50% {
                transform: scale(1.06)
            }

            100% {
                transform: scale(1)
            }
        }



        /* High-score HUD styles (small, unobtrusive) */
        #highScoreHud {
            color: #ffe9b0;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.6);
            opacity: 0.95;
            user-select: none;
        }

            #highScoreHud strong {
                font-weight: 700;
                margin-right: 6px;
                font-size: 11px;
            }

        #highScoreValue {
            font-family: 'Press Start 2P', monospace;
            font-size: 11px;
        }

        /* Assistant: low-click pulsing for clicks meter */
        @keyframes assist-pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 209, 102, 0.0);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 12px 6px rgba(255, 209, 102, 0.18);
                transform: scale(1.03);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 209, 102, 0.0);
                transform: scale(1);
            }
        }

        #clicksMeter.low-warning {
            animation: assist-pulse 900ms ease-in-out infinite;
            border-color: #ffd166;
            transform-origin: center;
        }

            #clicksMeter.low-warning .segment {
                /* optional: slightly brighten segments */
                filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.12));
            }


/* ------------ audio popup (matches badge/game-over styling but interactive) ------------- */
        .audio-popup {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0.98);
            z-index: 98000;
            width: min(520px, 86vw);
            max-width: 92%;
            padding: 18px 20px;
            border-radius: 12px;
            border: 6px solid rgba(0, 0, 0, 0.45);
            background: linear-gradient(180deg, #0b3d91, #08306a);
            color: #ffd166;
            box-shadow: 8px 8px 0 rgba(0, 0, 0, 0.25);
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            text-align: left;
            pointer-events: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 220ms ease, transform 220ms ease, visibility 0ms 220ms;
        }

            /* shown */
            .audio-popup.show {
                opacity: 1;
                visibility: visible;
                transform: translate(-50%, -50%) scale(1);
                transition: opacity 220ms ease, transform 220ms ease;
            }

            /* content rows */
            .audio-popup .row {
                display: flex;
                align-items: center;
                gap: 12px;
                margin: 10px 0;
            }

            .audio-popup label {
                width: 130px;
                font-size: 11px;
                color: #ffe9b0;
            }

            .audio-popup input[type="range"] {
                flex: 1;
                width: 100%;
                min-height: 32px;
                touch-action: pan-x;
                -webkit-tap-highlight-color: transparent;
                accent-color: #ffd166;
            }

            .audio-popup .controls {
                display: flex;
                gap: 10px;
                justify-content: flex-end;
                margin-top: 12px;
            }

            /* popup small button */
            .audio-popup .btn {
                border-radius: 8px;
                padding: 8px 12px;
                font-size: 11px;
                border: 4px solid rgba(0, 0, 0, 0.18);
                background: linear-gradient(180deg, #ffffff, #e6e3ff);
                color: #0b3d91;
                box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.12);
                cursor: pointer;
            }

        /* the HUD gear button uses same small-ctrl style already present; optional slight tweak for icon */
        .small-ctrl .gear-icon {
            width: 24px;
            height: 24px;
            display: inline-block;
            color: inherit;
        }

        .restart-icon {
            width: 24px;
            height: 24px;
            color: inherit;
        }


/* Ensure .wrap is a positioning context (safe to set again) */
        .wrap {
            position: relative;
        }

        /* Badge: always absolutely positioned relative to .wrap */
        #assist-badge {
            position: absolute !important;
            right: 12px !important;
            bottom: 12px !important;
            width: 65px !important;
            /* adjust size as desired */
            height: 65px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            border-radius: 8px !important;
            padding: 0 !important;
            /* remove internal padding that can shrink image */
            box-sizing: border-box !important;
            z-index: 9999 !important;
            pointer-events: auto !important;
        }

        /* Keep assistant speech bubble in viewport layer so it is never trapped under .wrap overlays */
        #assist-bubble {
            position: fixed !important;
            left: 12px;
            top: 12px;
            right: auto;
            bottom: auto;
            /* badge bottom + badge height (52) + 4px gap */
            max-width: min(78vw, 420px) !important;
            min-width: 220px !important;
            width: clamp(220px, 32vw, 380px) !important;
            height: auto !important;
            min-height: 0 !important;
            max-height: none !important;
            overflow-y: visible !important;
            padding: 8px 12px !important;
            border-radius: 10px !important;
            box-sizing: border-box !important;
            display: block !important;
            font-size: 16px !important;
            line-height: 1.35 !important;
            white-space: normal !important;
            word-break: break-word !important;
            pointer-events: none !important;
            z-index: 2147483646 !important;
        }

        #assist-text {
            margin: 0 !important;
            font-size: inherit !important;
            line-height: inherit !important;
        }

            /* Show state unchanged */
            #assist-bubble.show {
                opacity: 1 !important;
                transform: translateY(0) scale(1) !important;
                pointer-events: auto !important;
            }

        /* Ensure the face image fills the badge container */
        #assist-badge img {
            width: 100% !important;
            height: 100% !important;
            display: block !important;
            object-fit: contain !important;
            /* preserve aspect but fill available space */
            margin: 0 !important;
            padding: 0 !important;
            border-radius: inherit !important;
        }

        /* Assistant face expression & speaking animation */
        #assistant-face {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* only one mouth visible at a time; controlled by JS via classes on #assistant-badge */
        .mouth-shape {
            transition: opacity 160ms linear, transform 160ms ease;
        }

        /* expression helpers when we set a class on #assist-badge (e.g., .expr-smile) */
        #assist-badge.expr-neutral .mouth-shape.neutral {
            opacity: 1;
            transform: translateY(0);
        }

        #assist-badge.expr-neutral .mouth-shape.smile {
            opacity: 0;
        }

        #assist-badge.expr-neutral .mouth-shape.talk {
            opacity: 0;
        }

        #assist-badge.expr-neutral .mouth-shape.worried {
            opacity: 0;
        }

        #assist-badge.expr-smile .mouth-shape.smile {
            opacity: 1;
        }

        #assist-badge.expr-worried .mouth-shape.worried {
            opacity: 1;
        }

        #assist-badge.expr-talk .mouth-shape.talk {
            opacity: 1;
        }

        /* speaking jiggle for the whole badge (subtle) */
        @keyframes assist-jiggle {
            0% {
                transform: translateY(0) rotate(0deg);
            }

            25% {
                transform: translateY(-1px) rotate(-1deg);
            }

            50% {
                transform: translateY(0) rotate(0.6deg);
            }

            75% {
                transform: translateY(-0.6px) rotate(-0.8deg);
            }

            100% {
                transform: translateY(0) rotate(0deg);
            }
        }

        /* mouth wobble for the talk mouth (applies to polyline) */
        @keyframes mouth-wobble {
            0% {
                transform: translateY(0) rotate(0deg);
            }

            50% {
                transform: translateY(-1px) rotate(2deg);
            }

            100% {
                transform: translateY(0) rotate(-1deg);
            }
        }

        /* when the assistant is speaking, add subtle badge jiggle + mouth wobble */
        #assist-badge.speaking {
            animation: assist-jiggle 420ms ease-in-out infinite;
            transform-origin: center center;
        }

            #assist-badge.speaking .mouth-shape.talk {
                animation: mouth-wobble 320ms ease-in-out infinite;
            }

        /* Eyebrow styling & expression rules */
        #brow-left,
        #brow-right {
            transition: opacity 140ms linear, transform 140ms ease;
            transform-origin: center;
            stroke-linecap: round;
            stroke-linejoin: round;
            /* soft shadow if you like (optional) */
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.18));
        }

        /* Neutral: hidden or subtle */
        #assist-badge.expr-neutral #brow-left,
        #assist-badge.expr-neutral #brow-right {
            opacity: 0;
            transform: translateY(0) rotate(0deg);
        }

        /* Smile: slight raised relaxed brows */
        #assist-badge.expr-smile #brow-left,
        #assist-badge.expr-smile #brow-right {
            opacity: 1;
            transform: translateY(-1px) rotate(-2deg);
            stroke-width: 1.3;
            stroke: #ffb08a;
            /* optional softer color for smile */
        }

        /* Worried / gameOver: inward furrow */
        #assist-badge.expr-worried #brow-left {
            opacity: 1;
            transform: translateY(0.6px) rotate(10deg);
            stroke: #ffb08a;
            stroke-width: 1.6;
        }

        #assist-badge.expr-worried #brow-right {
            opacity: 1;
            transform: translateY(0.6px) rotate(-10deg);
            stroke: #ffb08a;
            stroke-width: 1.6;
        }

        /* Talk: quick little twitch while speaking */
        @keyframes brow-twitch {
            0% {
                transform: translateY(0) rotate(0deg);
            }

            30% {
                transform: translateY(-1px) rotate(-2deg);
            }

            60% {
                transform: translateY(1px) rotate(2deg);
            }

            100% {
                transform: translateY(0) rotate(0deg);
            }
        }

        #assist-badge.expr-talk.speaking #brow-left,
        #assist-badge.expr-talk.speaking #brow-right {
            opacity: 1;
            animation: brow-twitch 420ms ease-in-out infinite;
            stroke: #ffd166;
            stroke-width: 1.4;
        }

        /* Optional: high-anger or surprise variants */
        #assist-badge.expr-surprised #brow-left,
        #assist-badge.expr-surprised #brow-right {
            opacity: 1;
            transform: translateY(-3px) rotate(-6deg);
            stroke: #ffffff;
            stroke-width: 1.6;
        }

        /* one-off strong flick when .brow-flick is present */
        @keyframes brow-flick {
            0% {
                transform: translateY(0) rotate(0deg);
            }

            40% {
                transform: translateY(-3px) rotate(-8deg);
            }

            100% {
                transform: translateY(0) rotate(0deg);
            }
        }

        #assist-badge.brow-flick #brow-left,
        #assist-badge.brow-flick #brow-right {
            opacity: 1;
            animation: brow-flick 160ms ease-out 1;
        }

        /* hide all mouths by default */
        .mouth-shape {
            opacity: 0;
            transition: opacity 140ms linear, transform 160ms ease;
        }

        /* show only the neutral mouth when idle */
        #assist-badge.expr-neutral .mouth-shape.neutral {
            opacity: 1;
            transform: translateY(0);
        }

        /* show smile when appropriate */
        #assist-badge.expr-smile .mouth-shape.smile {
            opacity: 1;
            transform: translateY(0);
        }

        /* show zig-zag talk mouth while talking */
        #assist-badge.expr-talk .mouth-shape.talk {
            opacity: 1;
            transform: translateY(0);
        }

        /* show worried / frown */
        #assist-badge.expr-worried .mouth-shape.worried {
            opacity: 1;
            transform: translateY(0);
        }

        /* ensure talk mouth can wobble while speaking */
        #assist-badge.speaking .mouth-shape.talk {
            /* animation applied elsewhere if desired */
        }

        /* Retro monitor styling for small assistant badge */
        .retro-monitor {
            width: 100%;
            height: 100%;
            display: block;
            pointer-events: none;
            /* interaction remains at badge level */
        }

        /* screen outer/inner visuals (applied to the wrapper, not SVG internal) */
        .retro-screen {
            /* scanlines and subtle CRT curvature via SVG shapes, but we add a CSS overlay for scanlines glow */
            background-image: linear-gradient(transparent, rgba(0, 0, 0, 0.06)), repeating-linear-gradient(transparent 0 2px, rgba(0, 0, 0, 0.035) 2px 3px);
            background-blend-mode: overlay;
            mix-blend-mode: normal;
        }

        /* small glow when speaking */
        #assist-badge.speaking .retro-screen {
            box-shadow: 0 6px 18px rgba(255, 210, 100, 0.12), inset 0 0 12px rgba(255, 210, 100, 0.03);
            transform: translateZ(0);
            transition: box-shadow 180ms ease;
        }

        /* bezel / body style (optional fallback for non-SVG parts) */
        .retro-bezel {
            border-radius: 6px;
            overflow: visible;
        }

        /* make the tiny power LED pulse */
        .retro-led {
            transition: opacity 180ms ease, transform 180ms ease;
        }

        #assist-badge.speaking .retro-led {
            transform: scale(1.08);
            opacity: 1;
        }

        /* === Eyebrow visibility overrides for retro monitor SVG ===
           Place this after your other assistant CSS in <head>.
        */

        /* default: hide (keeps initial behavior) */
        #assist-badge .retro-monitor #brow-left,
        #assist-badge .retro-monitor #brow-right {
            opacity: 1 !important;
            transition: opacity 140ms linear, transform 140ms ease;
            transform-origin: center;
        }

        /* smile: slightly raised relaxed brows */
        #assist-badge.expr-smile .retro-monitor #brow-left,
        #assist-badge.expr-smile .retro-monitor #brow-right {
            opacity: 1 !important;
            transform: translateY(-1px) rotate(-2deg);
            stroke-width: 1.3;
            stroke: #bde58a;
        }

        /* worried / gameOver: inward furrow */
        #assist-badge.expr-worried .retro-monitor #brow-left {
            opacity: 1 !important;
            transform: translateY(0.6px) rotate(10deg);
            stroke: #ffb08a;
            stroke-width: 1.6;
        }

        #assist-badge.expr-worried .retro-monitor #brow-right {
            opacity: 1 !important;
            transform: translateY(0.6px) rotate(-10deg);
            stroke: #ffb08a;
            stroke-width: 1.6;
        }

        /* talk: quick twitch while speaking */
        #assist-badge.expr-talk.speaking .retro-monitor #brow-left,
        #assist-badge.expr-talk.speaking .retro-monitor #brow-right {
            opacity: 1 !important;
            animation: brow-twitch 420ms ease-in-out infinite;
            stroke: #ffd166;
            stroke-width: 1.4;
        }

        @keyframes brow-twitch {
            0% {
                transform: translateY(0) rotate(0deg);
            }

            30% {
                transform: translateY(-1px) rotate(-2deg);
            }

            60% {
                transform: translateY(1px) rotate(2deg);
            }

            100% {
                transform: translateY(0) rotate(0deg);
            }
        }

        /* === AI intro overlay === */
        .ai-intro-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, rgba(10, 10, 30, 0.95), rgba(0, 0, 0, 0.98));
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 120000;
            /* above everything else */
            color: #ffd166;
        }

        .ai-intro-content {
            text-align: center;
            max-width: 80vw;
        }

        .ai-face-slot {
            display: flex;
            justify-content: center;
            margin-bottom: 24px;
        }

        .ai-intro-text {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 20px;
            font-family: "Lucida Console", "Courier New", Courier, monospace;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.55);
        }

        .ai-start-btn {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            padding: 14px 28px;
            background: linear-gradient(180deg, #ffffff, #e6e3ff);
            color: #0b3d91;
            border: 4px solid rgba(0, 0, 0, 0.25);
            border-radius: 8px;
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.25);
            cursor: pointer;
            transition: transform 120ms ease;
        }

            .ai-start-btn:hover {
                transform: scale(1.05);
            }

        .ai-intro-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
            transition: opacity 600ms ease;
        }

        button.ctrl {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
        }

        .btn-icon {
            width: 33px; /* same as your SVG size */
            height: 33px;
            user-select: none;
            pointer-events: none; /* keeps clicks handled by the button */
        }
    
/* Assistant: added expressions - ensure neutral mouth is only visible when expr-neutral is present */
#assist-badge.expr-neutral .mouth-shape.neutral { opacity: 1 !important; transform: translateY(0); }
#assist-badge:not(.expr-neutral) .mouth-shape.neutral { opacity: 0 !important; }

/* New expression: wink (half-closed eye implied by brow tilt and wink mouth) */
#assist-badge.expr-wink .mouth-shape.wink { opacity: 1; transform: translateY(0); }
#assist-badge.expr-wink #brow-left { opacity: 0.9; transform: translateY(-1px) rotate(-6deg); stroke: #ffd166; stroke-width: 1.2; }

/* New expression: angry (furrowed brow + red angry mouth) */
#assist-badge.expr-angry .mouth-shape.angry { opacity: 1; transform: translateY(0) scaleY(1); }
#assist-badge.expr-angry #brow-left, #assist-badge.expr-angry #brow-right {
    opacity: 1;
    transform-origin: center;
    transform: translateY(1px) rotate(12deg);
    stroke: #ff6b6b;
    stroke-width: 1.8;
}

/* Ensure other expression rules do not accidentally enable neutral mouth */
#assist-badge.expr-smile .mouth-shape.neutral,
#assist-badge.expr-worried .mouth-shape.neutral,
#assist-badge.expr-talk .mouth-shape.neutral,
#assist-badge.expr-surprised .mouth-shape.neutral,
#assist-badge.speaking .mouth-shape.neutral {
    opacity: 0 !important;
}

/* make talk mouth animate only when speaking */
#assist-badge.expr-talk.speaking .mouth-shape.talk { animation: mouth-wobble 320ms ease-in-out infinite; }

/* small visual tweak: angry mouth color override */
#assist-badge.expr-angry .mouth-shape.angry { stroke: #ff6b6b; }


/* START-MISSION modal */
        #startModal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0.98);
            z-index: 130000;
            width: min(720px, 88vw);
            max-width: 92%;
            padding: 20px 20px 28px 20px;
            border-radius: 12px;
            border: 6px solid rgba(0, 0, 0, 0.6);
            background: #000;
            /* solid black background requested */
            color: #ffd166;
            /* requested text color */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            font-family: "Lucida Console", "Courier New", Courier, monospace;
            /* requested font + fallbacks */
            font-size: 14px;
            line-height: 1.45;
            display: none;
            gap: 12px;
        }

            /* visible state */
            #startModal.show {
                display: block;
                animation: modalIn 260ms ease both;
            }

            /* inner layout: text left, small image anchored bottom-right inside modal */
            #startModal .inner {
                position: relative;
                display: flex;
                align-items: flex-start;
                gap: 12px;
                min-height: 140px;
            }

            /* text column takes remaining width, left aligned */
            #startModal .modal-text {
                padding-right: 8px;
                flex: 1 1 auto;
                text-align: left;
                white-space: pre-line;
                color: #ffd166;
                font-size: 14px;
                text-indent: 0;
            }

            /* small image anchored bottom-right inside the modal */
            /* small image placed as a flex item to avoid overlapping text */
            #startModal .modal-img {
                position: static;
                right: auto;
                bottom: auto;
                width: 84px;
                height: auto;
                display: block;
                object-fit: contain;
                border-radius: 6px;
                pointer-events: none;
                image-rendering: -webkit-optimize-contrast;
                flex: 0 0 84px;
                margin-left: 12px;
                align-self: flex-end;
            }

            /* Close button */
            #startModal .close-btn {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                margin-top: 12px;
                padding: 10px 12px;
                border-radius: 8px;
                border: 4px solid rgba(0, 0, 0, 0.28);
                background: linear-gradient(180deg, #111, #333);
                color: #ffd166;
                cursor: pointer;
                font-family: "Lucida Console", "Courier New", Courier, monospace;
                font-size: 12px;
            }

        /* entry animation */
        @keyframes modalIn {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.96);
            }

            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        /* responsive: allow image to shrink on narrow screens */
        @media (max-width: 420px) {
            #startModal .modal-img {
                width: 56px;
                right: 8px;
                bottom: 8px;
            }

            #startModal {
                padding: 16px;
            }
        }


/* Assistant toggle styles */
.assistant-control { width:100%; box-sizing: border-box; }

/* Hide native checkbox but keep it accessible */
.assistant-toggle-input {
  position: absolute;
  left: -9999px;
  width: 1px;
  height: 1px;
  opacity: 0;
}

/* custom switch */
.assistant-toggle-switch {
  display:inline-block;
  width:46px;
  height:26px;
  background: rgba(255,255,255,0.12);
  border-radius: 999px;
  position: relative;
  transition: background .18s ease;
  vertical-align: middle;
  box-shadow: 0 2px 6px rgba(2,6,23,0.4);
}
.assistant-toggle-switch::after{
  content: "";
  position: absolute;
  left: 4px;
  top: 4px;
  width: 18px;
  height: 18px;
  background: white;
  border-radius: 50%;
  transition: transform .18s ease;
  box-shadow: 0 2px 6px rgba(2,6,23,0.25);
}

/* checked state */
.assistant-toggle-input:checked + .assistant-toggle-switch{
  background: linear-gradient(90deg, #34d399, #06b6d4);
}
.assistant-toggle-input:checked + .assistant-toggle-switch::after{
  transform: translateX(20px);
}

/* audio popup sizing */
.audio-popup { min-width: 420px; max-width: 90vw; padding: 14px; box-sizing: border-box; }


/* Assistant & AI UI */

/* Ensure AI assistant elements sit above all popups without altering layout */
        #assist-badge,
        .ai-assistant-bubble,
        .ai-intro-overlay,
        .assistant-bubble,
        .ai-face-slot,
        .ai-intro-content {
            z-index: 97000 !important;
        }


/* Added expressions: pout, grin, bigsurprised, smirk - use neutral stroke #ffd166 */
#assist-badge .mouth-shape.pout { transition: opacity 140ms linear, transform 160ms ease; }
#assist-badge.expr-pout .mouth-shape.pout { opacity: 1 !important; stroke: #ffd166; transform: translateY(0) !important; }

#assist-badge .mouth-shape.grin { transition: opacity 140ms linear, transform 160ms ease; }
#assist-badge.expr-grin .mouth-shape.grin { opacity: 1 !important; stroke: #ffd166; transform: translateY(0) !important; }

#assist-badge .mouth-shape.bigsurprised { transition: opacity 140ms linear, transform 160ms ease; }
#assist-badge.expr-bigsurprised .mouth-shape.bigsurprised { opacity: 1 !important; stroke: #ffd166; transform: translateY(0) !important; }

#assist-badge .mouth-shape.smirk { transition: opacity 140ms linear, transform 160ms ease; }
#assist-badge.expr-smirk .mouth-shape.smirk { opacity: 1 !important; stroke: #ffd166; transform: translateY(0) !important; }

/* Ensure all mouth shapes use the neutral stroke color by default */
#assist-badge .mouth-shape { stroke: #ffd166 !important; }

/* Ensure eyebrow strokes follow neutral color; target common eyebrow ids/classes if present */
#assist-badge #brow-left, #assist-badge #brow-right, #assist-badge .brow { stroke: #ffd166 !important; }

/* Defensive: neutral mouth only visible when expr-neutral */
#assist-badge:not(.expr-neutral) .mouth-shape.neutral { opacity: 0 !important; }
#assist-badge.expr-neutral .mouth-shape.neutral { opacity: 1 !important; stroke: #ffd166; }


/* Assistant disabled helper */
body.assistant-disabled #assist-badge,
body.assistant-disabled .assist-bubble,
body.assistant-disabled .assistant-face,
body.assistant-disabled #assistant-bubble-root,
body.assistant-disabled .assistant-fallback-bubble,
html.assistant-disabled #assist-badge,
html.assistant-disabled .assist-bubble,
html.assistant-disabled .assistant-face,
html.assistant-disabled #assistant-bubble-root,
html.assistant-disabled .assistant-fallback-bubble {
  display: none !important;
  opacity: 1 !important;
  pointer-events: none !important;
}


/* Minimal, mobile-first assistant styles */
        .assist-badge {
            position: fixed;
            right: 12px;
            bottom: 72px;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.35);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
            touch-action: manipulation;
            transform: scale(1.15);
        }

        .assist-badge img {
            width: 28px;
            height: 28px;
            display: block;
        }

        .assist-bubble {
            position: fixed;
            right: 12px;
            bottom: 40px;
            max-width: 72vw;
            min-width: 160px;
            padding: 8px 12px;
            border-radius: 10px;
            background: linear-gradient(180deg, #111, #222);
            color: #ffd166;
            font-family: monospace, 'Press Start 2P', sans-serif;
            font-size: 16px;
            z-index: 999999;
            pointer-events: none;
            opacity: 0;
            transform: translateY(6px) scale(0.98);
            transition: opacity 180ms ease, transform 200ms ease;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
        }

        .assist-bubble.show {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .assist-badge.notif {
            box-shadow: 0 0 0 4px rgba(255, 209, 102, 0.08), 0 4px 8px rgba(0, 0, 0, 0.25);
        }

        @media (max-width:420px) {
            .assist-bubble {
                max-width: 86vw;
                font-size: 13px;
                bottom: 110px;
            }
        }


/* HUD / Badge / Game UI */

/* Control trio: compact square buttons in HUD */
        .control-trio {
            display: flex;
            gap: 8px;
            align-items: center;
        }

            .control-trio .ctrl {
                width: 48px;
                height: 40px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-family: 'Press Start 2P', monospace;
                font-size: 12px;
                border-radius: 6px;
                border: 4px solid rgba(0, 0, 0, 0.18);
                background: linear-gradient(180deg, #ffffff, #e6e3ff);
                color: #0b3d91;
                box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.12);
                cursor: pointer;
                padding: 6px;
            }

        /* Slightly smaller on narrow screens */
        @media (max-width:420px) {
            .control-trio .ctrl {
                width: 40px;
                height: 36px;
                font-size: 10px;
            }
        }


/* Consolidated HUD small panel styles (base) */
        .hud .small {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            background: linear-gradient(180deg, rgba(0,0,0,0.12), rgba(255,255,255,0.02));
            padding: 10px 12px;
            border-radius: 8px;
            border: 4px solid rgba(0, 0, 0, 0.25);
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.12);
            min-width: 85px;
            color: #ffd166;
            font-family: 'Press Start 2P', monospace;
            font-size: 11px;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.55);
            box-sizing: border-box;
        }

        /* Scorebox variant uses left-justified stacking */
        .small.scorebox {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            text-align: left !important;
            line-height: 1.2;
            width: 100%;
        }

            /* Score lines inside scorebox */
            .small.scorebox .score-line,
            .small.scorebox .high-line {
                width: 100%;
                text-align: left !important;
            }

            .small.scorebox .score-line {
                font-size: 9px;
                color: #ffd166;
            }

            .small.scorebox .high-line {
                font-size: 8px;
                opacity: 0.85;
                color: #ffe9b0;
                margin-top: 2px;
                text-shadow: 1px 1px 0 rgba(0,0,0,0.55);
            }

        /* HUD button baseline */
        .hud button {
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(180deg, #ffffff, #e6e3ff);
            color: #0b3d91;
            border: 4px solid rgba(0,0,0,0.18);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.12);
            cursor: pointer;
            font-size: 11px;
            box-sizing: border-box;
        }

        /* Ensure board and wrap sizing predictable and prevent overflow from transient particles */
        .wrap {
            box-sizing: border-box;
            max-width: 100%;
            margin: 0 auto;
        }

        .board {
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
        }

        /* Keep .cell overflow hidden within cell (prevents per-cell overflow) */
        .cell {
            overflow: hidden;
        }

        /* Small screens tweak preserved */
        @media (max-width:420px) {
            .board {
                width: 94vw;
            }
        }


/* Animations / Confetti / Particles */

@keyframes breathe {
            0% {
                transform: scale(0.985);
            }

            50% {
                transform: scale(1.02);
            }

            100% {
                transform: scale(0.985);
            }
        }

        .virus--size-0 .face-sprite {
            animation: breathe var(--breathe-duration, 5.5s) ease-in-out infinite alternate;
            transform-origin: center;
            will-change: transform;
        }

        .virus--size-1 .face-sprite {
            animation: breathe var(--breathe-duration, 4.0s) ease-in-out infinite alternate;
            transform-origin: center;
            will-change: transform;
        }

        .virus--size-2 .face-sprite {
            animation: breathe var(--breathe-duration, 3.2s) ease-in-out infinite alternate;
            transform-origin: center;
            will-change: transform;
        }


/* Misc */

.small-ctrl {
            width: 100px;
            height: 40px;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            border: 4px solid rgba(0, 0, 0, 0.18);
            background: linear-gradient(180deg, #fff, #e6e3ff);
            color: #0b3d91;
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.12);
        }

        @media (max-width:420px) {
            .small-ctrl {
                width: 40px;
                height: 36px;
                font-size: 10px;
            }
        }


.level-complete .lc-hint {
            margin-top: 8px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.85);
            font-family: 'Press Start 2P', monospace;
            opacity: 0.9;
            text-align: center;
            pointer-events: none;
        }

/* Board-locked level popup: same size and position as the game board */
.level-complete.level-complete--board {
            position: fixed !important;
            transform: none !important;
            margin: 0 !important;
            box-sizing: border-box !important;
            display: grid !important;
            grid-template-rows: auto 1fr auto;
            gap: 10px;
            padding: 12px !important;
            overflow: hidden !important;
        }

.level-complete.level-complete--board .lc-title {
            margin: 0;
            font-size: clamp(12px, 2.1vmin, 22px);
            line-height: 1.1;
            text-align: center;
            white-space: normal;
        }

.level-complete.level-complete--board .lc-image {
            min-height: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

.level-complete.level-complete--board .lc-image img {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

.level-complete.level-complete--board .lc-hint {
            margin: 0;
            font-size: clamp(8px, 1.15vmin, 11px);
            line-height: 1.2;
            text-align: center;
        }

@keyframes levelInBoard {
            0% {
                opacity: 0;
                transform: scale(0.96);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

@keyframes levelOutBoard {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.97);
            }
        }

.level-complete.level-complete--board.show {
            animation: levelInBoard 260ms ease both !important;
            pointer-events: auto !important;
        }

.level-complete.level-complete--board.hide {
            animation: levelOutBoard 220ms ease both !important;
            pointer-events: none !important;
        }


</style>

</head>

<body>
    <div class="wrap">
        <div class="title-sprite">
            <img src="https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/Gone_Viral_long.png"
                alt="Gone Viral title" style="width:400px;max-width:80vw;height:auto;display:block;margin-bottom:10px;">
        </div>
        <div id="board" class="board" role="grid" aria-label="game board"></div>
        <div class="hud">
            <div class="hud-row">
                <div class="level-box">Level: <span id="screens">1</span></div>
                <div class="small scorebox">
                    <div class="score-line">Score: <span id="score">0</span></div>
                    <div class="high-line">High: <span id="highScoreValue">0</span></div>
                </div>
            </div>

            <div class="small meter" id="clicksMeter">
                <img class="meter-icon"
                    src="https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/nanobot.png"
                    alt="Nano Bot Icon" width="28" height="28">

                <div class="meter-segments">
                    <div class="seg filled pop" data-idx="0"></div>
                    <div class="seg filled pop" data-idx="1"></div>
                    <div class="seg filled pop" data-idx="2"></div>
                    <div class="seg filled pop" data-idx="3"></div>
                    <div class="seg filled pop" data-idx="4"></div>
                    <div class="seg" data-idx="5"></div>
                    <div class="seg" data-idx="6"></div>
                    <div class="seg" data-idx="7"></div>
                    <div class="seg" data-idx="8"></div>
                    <div class="seg" data-idx="9"></div>
                </div>
                <div class="meter-count"> <span id="clicks">10</span></div>
            </div>

            <div class="control-trio" role="group" aria-label="Controls">
                <button id="startBtn" class="ctrl small-ctrl" aria-label="S">
                    <img src="https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/start.png" alt="Start" class="btn-icon">
                </button>
                <button id="restart" class="ctrl small-ctrl" aria-label="Restart">
                    <img src="https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/reset.png" alt="Retart" class="btn-icon">
                </button>

                <button id="audioBtn" class="ctrl small-ctrl" aria-label="Audio Settings" title="Audio Settings" data-modal-open="audioPopup">
                    <img src="https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/gear.png" alt="Audio" class="btn-icon">
                </button>
                <button id="helpBtn" class="ctrl small-ctrl" aria-label="How to Play" title="How to Play">
                    <img src="https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/question.png" alt="Question" class="btn-icon">
                </button>
            </div>

            <div id="assist-badge" class="assist-badge" aria-live="polite" aria-atomic="true" title="Lab Assistant"
                 role="button">
                <!-- Inline retro monitor SVG: paste into #assist-badge -->
                <svg class="retro-monitor" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"
                     focusable="false">
                    <defs>
                        <linearGradient id="screenGrad" x1="0" x2="0" y1="0" y2="1">
                            <stop offset="0" stop-color="#0b1320" stop-opacity="0.85" />
                            <stop offset="1" stop-color="#001018" stop-opacity="0.98" />
                        </linearGradient>
                        <filter id="crt" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur in="SourceGraphic" stdDeviation="0.2" result="blur" />
                            <feMerge>
                                <feMergeNode in="blur" />
                                <feMergeNode in="SourceGraphic" />
                            </feMerge>
                        </filter>
                        <clipPath id="screenClip">
                            <rect x="10" y="10" width="44" height="44" rx="0" ry="0" />
                        </clipPath>
                    </defs>

                    <!-- monitor body / bezel -->
                    <!-- monitor body / bezel -->
                    <g class="retro-bezel" filter="url(#crt)">
                        <!-- outer case -->
                        <rect x="4" y="4" width="56" height="56" fill="#cfc9b0" stroke="#999684" stroke-width="1.8"
                              rx="0" ry="0" />
                        <!-- inner edge highlight -->
                        <rect x="7" y="7" width="50" height="50" fill="none" stroke="#e8e3cc" stroke-width="0.8" rx="0"
                              ry="0" />
                        <!-- subtle shadow edges -->
                        <rect x="6" y="6" width="52" height="52" fill="none" stroke="rgba(0,0,0,0.25)"
                              stroke-width="0.8" rx="0" ry="0" />

                        <!-- dark shadow base -->
                        <rect x="4" y="60" width="56" height="2" fill="#7d7865" opacity="0.6" />

                        <!-- tiny ventilation dots -->
                        <g opacity="0.25" transform="translate(10,58)">
                            <rect x="0" y="0" width="2" height="1" fill="#333" />
                            <rect x="4" y="0" width="2" height="1" fill="#333" />
                            <rect x="8" y="0" width="2" height="1" fill="#333" />
                            <rect x="12" y="0" width="2" height="1" fill="#333" />
                        </g>
                        <g opacity="0.75" transform="translate(10,58)">
                            <rect x="30" y="-11" width="2" height="1" fill="#333" />
                            <rect x="34" y="-11" width="2" height="1" fill="#333" />
                            <rect x="38" y="-11" width="2" height="1" fill="#333" />
                            <rect x="42" y="-11" width="2" height="1" fill="#333" />
                        </g>
                    </g>



                    <!-- screen area (we will place the face inside this group) -->
                    <g class="retro-screen" clip-path="url(#screenClip)">
                        <!-- screen background gradient -->
                        <rect x="10" y="10" width="44" height="34" fill="url(#screenGrad)" />
                        <!-- faint horizontal reflection -->
                        <rect x="10" y="10" width="44" height="12" fill="rgba(255,255,255,0.02)" />
                        <!-- scanlines are handled by CSS overlay on the containing element, but we also add a subtle pattern via thin lines -->
                        <g opacity="0.06" transform="translate(0,9)">
                            <rect x="10" y="0" width="44" height="34" fill="url(#screenGrad)" />
                        </g>

                        <!-- INSERT FACE GROUP (you can include your existing inline SVG face here) -->
                        <g id="monitor-face" transform="translate(0,0)">
                            <!-- a small copy of eyes+mouth centered on the screen -->
                            <g transform="translate(0,0) scale(0.78) translate(8,2)">
                                <!-- eyes -->
                                <circle cx="21.5" cy="24" r="3.2" fill="#ffd166" />
                                <circle cx="42.5" cy="24" r="3.2" fill="#ffd166" />

                                <!-- eyebrows -->
                                <path id="brow-left" d="M14 18 L22 16" stroke="#ffd166" stroke-width="1.4"
                                      stroke-linecap="round" opacity="0" />
                                <path id="brow-right" d="M42 16 L50 18" stroke="#ffd166" stroke-width="1.4"
                                      stroke-linecap="round" opacity="0" />

                                <!-- mouth shapes: neutral + talk + smile etc. -->

                                <g id="monitor-mouth" transform="translate(0,6)">
                                    <path class="mouth-shape neutral" d="M22 36c4 0 20 0 20 0" stroke="#ffd166"
                                          stroke-width="1.6" stroke-linecap="round" fill="none" />
                                    <polyline class="mouth-shape talk" points="18,35 24,30 30,35 36,30 42,35"
                                              fill="none" stroke="#ffd166" stroke-width="1.6" stroke-linecap="round"
                                              stroke-linejoin="round" />
                                    <path class="mouth-shape smile" d="M20 34c6 6 18 6 24 0" stroke="#ffd166"
                                          stroke-width="1.8" stroke-linecap="round" fill="none" />
                                    <path class="mouth-shape wink" d="M18 36c3 0 6 -6 12 -6" stroke="#ffd166" stroke-width="1.6" stroke-linecap="round" fill="none" />
                                    <path class="mouth-shape angry" d="M20 36c6 -6 18 -6 24 0" stroke="#ff6b6b" stroke-width="1.8" stroke-linecap="round" fill="none" />

                                
                                    <path class="mouth-shape worried" d="M20 36c6 6 18 -6 24 0" stroke="#ffd166" stroke-width="1.6" stroke-linecap="round" fill="none"/>

                                    <path class="mouth-shape pout" d="M20 36c6 2 18 2 24 0" stroke="#ffd166" stroke-width="1.4" stroke-linecap="round" fill="none" opacity="0" />
                                    <path class="mouth-shape grin" d="M18 34c6 8 18 8 24 0" stroke="#ffd166" stroke-width="1.6" stroke-linecap="round" fill="none" opacity="0" />
                                    <path class="mouth-shape bigsurprised" d="M22 32c4 10 12 10 20 0" stroke="#ffd166" stroke-width="1.6" stroke-linecap="round" fill="none" opacity="0" />
                                    <path class="mouth-shape smirk" d="M18 36c6 0 18 -2 24 -4" stroke="#ffd166" stroke-width="1.2" stroke-linecap="round" fill="none" opacity="0" />
</g>
                            </g>
                        </g>
                    </g>

                    <!-- base / stand -->
                    <rect x="3" y="50" width="58" height="1" rx="0" fill="#00000" />
                    <rect x="12" y="45.5" width="6" height="3" rx="0" fill="#999684" />

                    <rect x="42" y="53" width="12" height="2" rx="0.5" fill="#0b0b0b" />
                    <!-- tiny LED -->
                    <circle class="retro-led" cx="10" cy="47" r="1.0" fill="#34a832" opacity="0.9" />

                </svg>


                </svg>


                </svg>
            </div>
            <div id="assist-bubble" class="assist-bubble" role="status">
                <div id="assist-text">...</div>
            </div>
        </div>
    </div>

    <script>

        // Put this near top of your script (edit paths to your images)
const levelCompleteImages = [
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster01.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster02.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster03.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster04.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster05.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster06.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster07.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster08.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster09.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster13.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster14.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster15.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster16.png',
  'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster17.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster20.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster21.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster22.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster26.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster27.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster28.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster32.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster33.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster34.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster35.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster36.png',
    'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/poster38.png'
];


function showLevelComplete(opts = {}) {
  const title = opts.title || 'LEVEL COMPLETE';
  const imgSrc = opts.imageUrl || levelCompleteImages[Math.floor(Math.random() * levelCompleteImages.length)] || '';

  // remove any previous popup
  const prior = document.querySelector('.level-complete');
  if (prior) try { prior.remove(); } catch (e) {}

  try {
    const el = document.createElement('div');
    el.className = 'level-complete level-complete--board';
    el.setAttribute('role', 'status');
    el.setAttribute('aria-live', 'polite');
    el.innerHTML = `
      <div class="lc-title">${title}</div>
      <div class="lc-image"><img src="${imgSrc}" alt="" /></div>
      <div class="lc-hint">Click to continue</div>
    `;
    document.body.appendChild(el);

    const positionOverBoard = () => {
      try {
        const board = document.getElementById('board') || document.querySelector('.board');
        if (!board) return;
        const r = board.getBoundingClientRect();
        const w = Math.max(120, Math.round(r.width));
        const h = Math.max(120, Math.round(r.height));
        el.style.left = Math.round(r.left) + 'px';
        el.style.top = Math.round(r.top) + 'px';
        el.style.width = w + 'px';
        el.style.height = h + 'px';
      } catch (e) { }
    };
    const onViewportChange = () => positionOverBoard();
    positionOverBoard();
    window.addEventListener('resize', onViewportChange);
    window.addEventListener('scroll', onViewportChange, true);

    // show popup
    void el.offsetWidth;
    el.classList.add('show');
    try { if (window.Assistant) Assistant.emit && Assistant.emit('levelComplete'); } catch (e) {}

    // make persistent until user click or keypress
    el.style.pointerEvents = 'auto';
    el.tabIndex = 0;
    el.style.cursor = 'pointer';

    const dismiss = () => {
      window.removeEventListener('resize', onViewportChange);
      window.removeEventListener('scroll', onViewportChange, true);
      el.classList.remove('show');
      el.classList.add('hide');
      el.addEventListener('animationend', () => { try { el.remove(); } catch (e) {} }, { once: true });
      document.removeEventListener('keydown', keyHandler);
    };

    const keyHandler = (ev) => {
      if (ev.key === 'Enter' || ev.key === ' ' || ev.key === 'Spacebar') {
        dismiss();
      }
    };

    el.addEventListener('click', dismiss, { once: true });
    document.addEventListener('keydown', keyHandler);

  } catch (e) {
    console.warn('showLevelComplete error', e);
  }
}


// small helpers to avoid injecting raw HTML unsafely (useful if title or url come from outside)
function escapeHtml(str) {
  return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;'}[s]));
}
function escapeHtmlAttr(str) {
  return String(str).replace(/"/g, '&quot;').replace(/&/g, '&amp;');
}

        // Difficulty tuning: base density and growth per screen (fraction 0..1)
        const BASE_DENSITY = 0.60;       // fraction of cells initially filled (0..1)
        const DENSITY_GROWTH = 0.0;   // fraction added each screenPassed;   // fraction added each screenPassed

        // Wrap everything that queries DOM in DOMContentLoaded so elements exist before we attach listeners
        document.addEventListener('DOMContentLoaded', () => {


            // initialize high score HUD
            try { highScoreEl = document.getElementById('highScoreValue'); if (highScoreEl) highScoreEl.textContent = String(highScore); } catch (e) { }
            // Full game script preserved from original with badge/confetti and 8-bit icons added
            const ROWS = 6, COLS = 6, MAX_SIZE = 3, MAX_CLICKS = 20;

            // ---------- Render scheduling (prevents redundant reflows) ----------
            const IS_MOBILE_COARSE = !!((window.matchMedia && window.matchMedia('(pointer: coarse)').matches) || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent));
            let renderQueued = false;
            function scheduleRender() {
                if (renderQueued) return;
                renderQueued = true;
                const flushRender = () => {
                    try { render(); } catch (e) { console.warn('render failed', e); }
                    renderQueued = false;
                };
                // On mobile, align render with the display refresh for smoother scrolling/battery.
                if (IS_MOBILE_COARSE && typeof requestAnimationFrame === 'function') requestAnimationFrame(flushRender);
                else setTimeout(flushRender, 0);
            }


            const SPRITE_URLS = [
                'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/Test_pixel.png',
                'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/virus2.png',
                'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/virus3.png',
                'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/virus4.png'
            ];
            const PETRI_URL = 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/petri%20dish.png';
            const SFX_URLS = {
                pop: 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/pop2.mp3',
                grow: 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/grow.mp3',
                fill: 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/bubblefill2.mp3',
                win: 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/win2.mp3',
                lose: 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/lose2.mp3'
            };

            // Background music playlist (hard-wired) — will be started on the user's first tap
            const MUSIC_PLAYLIST = [
                'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/Voltaic.mp3',
                'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/Robobozo.mp3'
            ];
            let musicOrder = [];
            let musicIndex = 0;
            let musicAudio = null;
            let musicSilenceMs = 2000; // 2 seconds silence between tracks
            let musicEnabled = true;

            let sfxCache = {};
            function createSfx(key) { const url = SFX_URLS[key]; if (!url) return null; try { const a = new Audio(url); a.preload = 'auto'; a.volume = 0.5; a.crossOrigin = 'anonymous'; sfxCache[key] = a; return a; } catch (e) { return null; } }
            function getSfx(key) { return sfxCache[key] || createSfx(key); }
            function playSfx(key) { try { const a = getSfx(key); if (!a) return; a.currentTime = 0; const p = a.play(); if (p && p.catch) p.catch(() => { }); } catch (e) { } }

            function shuffleArray(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[arr[i], arr[j]] = [arr[j], arr[i]]; } }
            function prepareMusicOrder() { musicOrder = MUSIC_PLAYLIST.slice(); shuffleArray(musicOrder); musicIndex = 0; }
            function playNextMusicTrack() {
                if (!musicEnabled) return; if (musicAudio) { try { musicAudio.pause(); musicAudio.src = ''; } catch (e) { } musicAudio = null; }
                if (musicOrder.length === 0) prepareMusicOrder(); const url = musicOrder[musicIndex % musicOrder.length]; musicAudio = new Audio(url); musicAudio.volume = 0.20; musicAudio.preload = 'auto'; musicAudio.crossOrigin = 'anonymous';
                const onEnded = () => { // schedule next after silence
                    musicAudio.removeEventListener('ended', onEnded);
                    setTimeout(() => { musicIndex = (musicIndex + 1) % musicOrder.length; playNextMusicTrack(); }, musicSilenceMs);
                };
                musicAudio.addEventListener('ended', onEnded);
                const playPromise = musicAudio.play(); if (playPromise && playPromise.catch) { playPromise.catch(() => { /* ignore */ }); }
            }
            // ---- audio settings hookup inserted by ChatGPT v4 ----
            try {
                // expose musicVolume and allMuted into local scope if not present
                if (typeof musicVolume === 'undefined') var musicVolume = (window.musicVolume !== undefined) ? window.musicVolume : 0.20;
                if (typeof allMuted === 'undefined') var allMuted = (window.allMuted !== undefined) ? window.allMuted : false;
                window.musicVolume = window.musicVolume || musicVolume;
                window.allMuted = window.allMuted || allMuted;

                // wrap playNextMusicTrack so newly created musicAudio picks up volume/mute
                try {
                    // ensure newly-created musicAudio is usable from both local and window scope
                    const _origPlayNext = playNextMusicTrack;
                    playNextMusicTrack = function () {
                        const res = _origPlayNext.apply(this, arguments);
                        try {
                            // if a musicAudio variable was created/assigned by playNextMusicTrack, normalize it:
                            if (typeof musicAudio !== 'undefined' && musicAudio) {
                                // keep volume/mute in sync with UI variables
                                musicAudio.volume = (typeof musicVolume !== 'undefined') ? musicVolume : (window.musicVolume || musicAudio.volume || 0.20);
                                musicAudio.muted = !!(typeof allMuted !== 'undefined' ? allMuted : window.allMuted);
                                // expose to window so other handlers (startBtn, etc.) can see the same instance
                                try { window.musicAudio = musicAudio; } catch (e) { /* best-effort */ }
                            } else if (window.musicAudio) {
                                // if playNextMusicTrack assigned to window.musicAudio instead, ensure its props are set likewise
                                try {
                                    window.musicAudio.volume = (typeof musicVolume !== 'undefined') ? musicVolume : (window.musicVolume || window.musicAudio.volume || 0.20);
                                    window.musicAudio.muted = !!(typeof allMuted !== 'undefined' ? allMuted : window.allMuted);
                                } catch (e) { }
                            }
                        } catch (e) { /* ignore errors */ }
                        return res;
                    };

                } catch (e) { }

                // wire UI sliders directly to local musicAudio and to local vars
                const mSlider = document.getElementById('musicVol');
                const sSlider = document.getElementById('sfxVol');
                const mVal = document.getElementById('musicVolVal');
                const sVal = document.getElementById('sfxVolVal');
                const popupMute = document.getElementById('popupMute');

                if (mSlider) {
                    // initialize slider
                    mSlider.value = String((typeof musicAudio !== 'undefined' && musicAudio && musicAudio.volume !== undefined) ? musicAudio.volume : (window.musicVolume || 0.20));
                    if (mVal) mVal.textContent = Math.round(Number(mSlider.value) * 100) + '%';
                    mSlider.addEventListener('input', function (e) {
                        var v = Number(e.target.value);
                        try { musicVolume = v; } catch (e) { }
                        window.musicVolume = v;
                        if (typeof musicAudio !== 'undefined' && musicAudio) {
                            try { musicAudio.volume = v; } catch (e) { }
                        }
                    });
                }

                if (sSlider) {
                    sSlider.value = String(window.sfxVolume || 0.50);
                    if (sVal) sVal.textContent = Math.round(Number(sSlider.value) * 100) + '%';
                }

                if (popupMute) {
                    // make popup mute call the page's existing mute button if present
                    popupMute.addEventListener('click', function () {
                        try {
                            var mainMute = document.getElementById('mute');
                            if (mainMute && typeof mainMute.click === 'function') {
                                mainMute.click();
                            } else {
                                // fallback: toggle local variables and apply
                                var nm = !((typeof allMuted !== 'undefined') ? allMuted : window.allMuted);
                                try { allMuted = nm; } catch (e) { }
                                window.allMuted = nm;
                                if (typeof musicAudio !== 'undefined' && musicAudio) try { musicAudio.muted = !!nm; } catch (e) { }
                                // also mute sfx cache
                                try { if (typeof sfxCache !== 'undefined' && sfxCache) Object.values(sfxCache).forEach(function (a) { if (a) a.muted = !!nm; }); } catch (e) { }
                            }
                        } catch (e) { }
                    });
                }

            } catch (e) { }
            // ---- end inserted block ----

            function startBackgroundMusic() { try { if (!musicOrder.length) prepareMusicOrder(); playNextMusicTrack(); } catch (e) { console.warn('startBackgroundMusic failed', e); } }
            function stopBackgroundMusic() {
                try {
                    // stop and clear any local reference
                    if (typeof musicAudio !== 'undefined' && musicAudio) {
                        try { musicAudio.pause(); } catch (e) { }
                        try { musicAudio.currentTime = 0; } catch (e) { }
                        musicAudio = null;
                    }
                    // also stop/clear any window-level audio reference (covers other code paths)
                    if (window.musicAudio) {
                        try { window.musicAudio.pause(); } catch (e) { }
                        try { window.musicAudio.currentTime = 0; } catch (e) { }
                        try { window.musicAudio = null; } catch (e) { /* ignore */ }
                    }
                } catch (e) {
                    // final safety - don't leak exceptions to UI
                    console.warn('stopBackgroundMusic error', e);
                }
            }

            // Game difficulty & state
            let clicksLeft = 10, screensPassed = 0, totalScore = 0;
            let outOfClicksShown = false;
            let state = new Array(ROWS * COLS).fill(null);
            let inputLocked = false;

            // Move DOM element lookups inside DOMContentLoaded
            const boardEl = document.getElementById('board');
            const clicksEl = document.getElementById('clicks');
            const screensEl = document.getElementById('screens');
            const scoreEl = document.getElementById('score');


            // High-score persistence (localStorage)
            const highScoreKey = 'goneViral_highScore';
            let highScore = Number(localStorage.getItem(highScoreKey) || 0);
            let highScoreEl = null;

            function updateHUD() {

                // ensure high score element is available
                if (!highScoreEl) try { highScoreEl = document.getElementById('highScoreValue'); } catch (e) { }
                if (clicksEl) clicksEl.textContent = clicksLeft; if (screensEl) screensEl.textContent = (screensPassed + 1); if (scoreEl) scoreEl.textContent = totalScore;
                // --- high-score handling ---
                if (typeof highScore !== 'number') highScore = 0;
                if (totalScore > highScore) {
                    highScore = totalScore;
                    try { localStorage.setItem(highScoreKey, String(highScore)); } catch (e) { }
                    if (highScoreEl) highScoreEl.textContent = String(highScore);
                }
                // Update the floating score box (5 digits, zero-padded)

                const disp = document.getElementById('scoreDisplay');
                if (disp) {
                    const s = String(totalScore).padStart(5, '0').slice(-5);
                    disp.textContent = s;
                }

                // Always update meter visuals and notify assistant when clicks are low
                try {
                    const meter = document.getElementById('clicksMeter');
                    if (meter) {

                        if (meter) {
                            if (clicksLeft <= 2) {
                                if (!meter.classList.contains('low-warning')) {
                                    meter.classList.add('low-warning');
                                    // restart animation by forcing reflow
                                    void meter.offsetWidth;
                                }
                            } else {
                                meter.classList.remove('low-warning');
                            }
                        }

                    }

                    // Assistant low-click guard: trigger once when clicks drop to <=2
                    if (typeof window._assistantLowShown === 'undefined') window._assistantLowShown = false;
                    if (clicksLeft <= 2 && !window._assistantLowShown) {
                        try { if (window.Assistant && Assistant.emit) Assistant.emit('lowClicks', { clicksLeft }); } catch (e) { }
                        window._assistantLowShown = true;
                    }
                    if (clicksLeft > 2 && window._assistantLowShown) {
                        window._assistantLowShown = false;
                    }
                } catch (e) {
                    console.warn('low-clicks HUD update failed', e);
                }

                // update pixel meter visualization (10 segments)
                try { updateClicksMeter(clicksLeft); } catch (e) { }
            }

            // Unified reset used by the Game Over persistent popup and restart wiring
            function performGameReset() {
                try {
                    screensPassed = 0;
                    totalScore = 0;
                    randomizeBoard(false);
                    updateHUD();
                    outOfClicksShown = false;
                } catch (e) { console.warn('performGameReset failed', e); }
            }


            // ---------- Level complete popup helper ----------
            

            // ---------- Game Over popup helper ----------

            function showGameOverPopup(opts = {}) {
                // opts: { title, subtitle, duration (ms), persistent (bool) }
                const title = opts.title || 'GAME OVER';
                const subtitle = opts.subtitle || 'Try Again';
                const duration = (typeof opts.duration === 'number') ? opts.duration : 1800;
                const persistent = !!opts.persistent;

                try {
                    // create element
                    const el = document.createElement('div');
                    el.className = 'game-over-popup';
                    el.setAttribute('role', 'alert');
                    el.style.pointerEvents = persistent ? 'auto' : 'none';
                    el.innerHTML = `
                                                                                  <div class="go-title">${title}</div>
                                                                                  <div class="go-sub">${subtitle}</div>
                                                                                `;
                    document.body.appendChild(el);
                    // Make Game Over popup clickable to restart (Option A)
                    try {
                        el.style.cursor = 'pointer';
                        el.title = 'Click to restart';
                        el.addEventListener('click', function restartFromPopup(ev) {
                            try {
                                // reset game state
                                if (typeof performGameReset === 'function') performGameReset();
                                // remove popup element if still present
                                try { if (el && el.parentNode) el.parentNode.removeChild(el); } catch (e) { }
                                // notify assistant (optional)
                                try { if (window.Assistant && Assistant.emit) Assistant.emit('levelComplete', { title: 'Restarted after Game Over' }); } catch (e) { }
                            } catch (e) { console.warn('restart click handler failed', e); }
                        }, { once: true });
                    } catch (e) { console.warn('could not attach restart click handler', e); }

                    void el.offsetWidth;
                    el.classList.add('show');
                    try { if (window.Assistant) Assistant.emit && Assistant.emit('gameOver', { title: title, subtitle: subtitle }); } catch (e) { }


                    if (persistent) {
                        // leave it on screen until user clicks the existing #restart button
                        // ensure restart button exists and wire a one-time handler
                        const restartBtn = document.getElementById('restart');
                        const cleanup = () => {
                            try {
                                if (el) {
                                    el.classList.remove('show');
                                    el.classList.add('hide');
                                    el.addEventListener('animationend', () => { try { el.remove(); } catch (e) { } }, { once: true });
                                }
                            } catch (e) { }
                        };
                        if (restartBtn) {
                            // avoid double-wiring
                            if (!restartBtn._gop_wired) {
                                restartBtn._gop_wired = true;
                                restartBtn.addEventListener('click', function onRestartFromGOP(e) {
                                    // cleanup popup and perform reset
                                    cleanup();
                                    try {
                                        // clear the outOfClicksShown guard so future gameovers can show
                                        outOfClicksShown = false;
                                    } catch (e) { }
                                    // call a unified reset if present
                                    if (typeof performGameReset === 'function') {
                                        try { performGameReset(); } catch (e) { }
                                    } else {
                                        try {
                                            screensPassed = 0;
                                            totalScore = 0;
                                            randomizeBoard(false);
                                            updateHUD();
                                        } catch (e) { }
                                    }
                                    // remove this handler flag (keep listener but it's idempotent)
                                });
                            }
                        } else {
                            // If no restart button, leave the popup until manually removed
                            console.warn('showGameOverPopup: persistent requested but #restart button not found.');
                        }
                        return;
                    }

                    // non-persistent: Hide and cleanup after delay
                    setTimeout(() => {
                        try {
                            el.classList.remove('show');
                            el.classList.add('hide');
                            el.addEventListener('animationend', () => el.remove(), { once: true });
                        } catch (e) { }
                    }, duration);
                } catch (e) {
                    console.warn('showGameOverPopup error', e);
                }
            }



            // Create and update meter functions
            function createClicksMeter(segmentsCount = 10) { const container = document.querySelector('.meter-segments'); if (!container) return; container.innerHTML = ''; for (let i = 0; i < segmentsCount; i++) { const s = document.createElement('div'); s.className = 'seg'; s.dataset.idx = i; container.appendChild(s); } }
            function updateClicksMeter(clicks) { const container = document.querySelector('.meter-segments'); if (!container) return; const segs = Array.from(container.children); const segCount = segs.length || 10; const toFill = Math.round((clicks / MAX_CLICKS) * segCount); segs.forEach((el, i) => { const should = i < toFill; if (should && !el.classList.contains('filled')) { el.classList.add('filled'); el.classList.remove('pop'); void el.offsetWidth; el.classList.add('pop'); } else if (!should && el.classList.contains('filled')) { el.classList.remove('filled'); el.classList.remove('pop'); } }); }

            function shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[arr[i], arr[j]] = [arr[j], arr[i]]; } }

            // ---------- Level-adaptive size-mix (two-phase) ----------
            // Start / middle / end mixes. Arrays should sum to 1 but code will normalize defensively.
            const SIZE_MIX_START = [0.10, 0.25, 0.30, 0.35]; // early levels: favor large (size 3)
            const SIZE_MIX_EVEN = [0.25, 0.25, 0.25, 0.25]; // middle: even distribution
            const SIZE_MIX_END = [0.35, 0.30, 0.25, 0.10]; // late: favor small (size 0)

            // Levels controlling the interpolation durations
            const LEVELS_TO_EVEN = 5;   // START -> EVEN over these many levels
            const LEVELS_TO_END = 12;  // EVEN -> END over these many levels (after the above)

            // Helper: linear interpolation between two arrays
            function lerpArrays(a, b, t) {
                const out = new Array(Math.max(a.length, b.length));
                for (let i = 0; i < out.length; i++) {
                    const ai = (i < a.length) ? a[i] : 0;
                    const bi = (i < b.length) ? b[i] : 0;
                    out[i] = ai + (bi - ai) * t;
                }
                return out;
            }

            // Debug HUD: create an overlay element to show the current interpolated mix
            function ensureSizeMixDebugElement() {
                let el = document.getElementById('sizeMixDebug');
                if (!el) {
                    el = document.createElement('div');
                    el.id = 'sizeMixDebug';
                    el.style.position = 'fixed';
                    el.style.right = '12px';
                    el.style.top = '12px';
                    el.style.zIndex = 99999;
                    el.style.background = 'rgba(0,0,0,0.65)';
                    el.style.color = '#ffd166';
                    el.style.padding = '8px 10px';
                    el.style.fontFamily = 'monospace';
                    el.style.fontSize = '12px';
                    el.style.borderRadius = '8px';
                    el.style.pointerEvents = 'none';
                    document.body.appendChild(el);
                }
                return el;
            }
            const SHOW_SIZE_MIX_DEBUG = !!window.DEBUG_SIZE_MIX;
            function updateSizeMixDebug(weights, levelNum) {
                if (!SHOW_SIZE_MIX_DEBUG) return;
                const el = ensureSizeMixDebugElement();
                if (!el) return;
                const pct = weights.map((w, i) => `s${i}:${Math.round(w * 100)}%`).join(' ');
                el.textContent = `L${levelNum} ${pct}`;
            }

            // Weighted sampler that adapts based on screensPassed (levels completed)
            function sampleSizeRandom() {
                const dims = MAX_SIZE + 1;
                // helper to ensure arrays are the right length
                function ensureLen(arr) {
                    const out = arr.slice(0, dims);
                    while (out.length < dims) out.push(0);
                    return out;
                }
                const S = ensureLen(SIZE_MIX_START);
                const M = ensureLen(SIZE_MIX_EVEN);
                const E = ensureLen(SIZE_MIX_END);

                let weights;
                if (typeof screensPassed === 'undefined') {
                    // fallback to uniform if screensPassed not yet defined
                    weights = new Array(dims).fill(1 / dims);
                } else if (screensPassed <= LEVELS_TO_EVEN) {
                    const t1 = LEVELS_TO_EVEN === 0 ? 1 : (screensPassed / LEVELS_TO_EVEN);
                    weights = lerpArrays(S, M, t1);
                } else if (screensPassed <= LEVELS_TO_EVEN + LEVELS_TO_END) {
                    const local = screensPassed - LEVELS_TO_EVEN;
                    const t2 = LEVELS_TO_END === 0 ? 1 : (local / LEVELS_TO_END);
                    weights = lerpArrays(M, E, t2);
                } else {
                    weights = E.slice();
                }

                // Normalize defensively
                const sum = weights.reduce((a, b) => a + b, 0) || 1;
                for (let i = 0; i < weights.length; i++) weights[i] = weights[i] / sum;

                // Update debug HUD with current mix (disabled by default)
                updateSizeMixDebug(weights, (screensPassed || 0) + 1);

                // Weighted sample by cumulative weights
                let r = Math.random();
                for (let i = 0; i < weights.length; i++) {
                    if (r < weights[i]) return i;
                    r -= weights[i];
                }
                return weights.length - 1;
            }


            function randomizeBoard(preserveClicks = false) {
                state.fill(null); if (!preserveClicks) clicksLeft = 10; const total = ROWS * COLS;
                const target = Math.round(total * Math.min(0.95, BASE_DENSITY + screensPassed * DENSITY_GROWTH)); const idx = Array.from({ length: total }, (_, i) => i); shuffle(idx); for (let k = 0; k < target; k++) { state[idx[k]] = sampleSizeRandom(); } scheduleRender(); updateHUD();
            }

            function findNextBubble(index, dr, dc) { let r = Math.floor(index / COLS), c = index % COLS; while (true) { r += dr; c += dc; if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return null; const i = r * COLS + c; if (state[i] !== null) return i; } }

            function createPetriElement() { const pet = document.createElement('div'); pet.className = 'petri'; if (PETRI_URL) { const img = document.createElement('img'); img.src = PETRI_URL; img.alt = 'petri'; pet.appendChild(img); } return pet; }

            function createVirusContainer(size) { const container = document.createElement('div'); container.className = 'virus virus--size-' + size; const sprite = document.createElement('div'); sprite.className = 'face-sprite'; const img = document.createElement('img'); img.className = 'face-img'; img.src = SPRITE_URLS[Math.max(0, Math.min(3, size))]; img.alt = 'virus'; const sizeScales = [0.4, 0.6, 0.8, 1.0]; img.style.transform = 'scale(' + sizeScales[Math.max(0, Math.min(3, size))] + ')'; img.style.transformOrigin = 'center center'; sprite.appendChild(img); container.appendChild(sprite); const stain = document.createElement('div'); stain.className = 'stain'; container.appendChild(stain); return container; }

            function render() {
                boardEl.innerHTML = ''; for (let i = 0; i < ROWS * COLS; i++) {
                    const val = state[i]; const gridCell = document.createElement('div'); gridCell.className = 'cell'; gridCell.dataset.index = i; // petri underlay
                    const pet = createPetriElement(); gridCell.appendChild(pet);
                    if (val !== null) { const container = createVirusContainer(val); gridCell.appendChild(container); }
                    boardEl.appendChild(gridCell);
                }
                updateHUD();
                const remaining = state.filter(x => x !== null).length;

                if (remaining === 0) {
                    // single, unified "level complete" path
                    clicksLeft = Math.min(MAX_CLICKS, clicksLeft + 1);
                    playSfx('win');
                    screensPassed += 1;
                    updateHUD();

                    try { showLevelComplete({ title: 'LEVEL COMPLETE', duration: 4500 }); } catch (e) { }

                    // wait a moment for the popup/animation, then new board
                    setTimeout(() => randomizeBoard(true), 420);
                }


            }

            // Particle pool
            const PARTICLE_POOL = [];
            // ---------- Sprite-based particle implementation (replacement) ----------
            const PARTICLE_SPRITE = 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/antibody.png';

            // Create a pooled particle element (an <img> inside a .particle wrapper)
            function makeAntibodyParticle(sizeVariant = 'normal', rotationDeg = 0) {
                const wrapper = document.createElement('div');
                wrapper.className = 'particle';
                if (sizeVariant === 'small') wrapper.classList.add('small');
                else if (sizeVariant === 'large') wrapper.classList.add('large');

                // create img child for the sprite
                const img = document.createElement('img');
                img.src = PARTICLE_SPRITE;
                img.alt = '';
                img.draggable = false;
                wrapper.appendChild(img);

                // runtime flags
                wrapper._inUse = false;
                wrapper._releaseTimeout = null;

                // safety: transitionend cleanup (so we can release when transform finishes)
                wrapper.addEventListener('transitionend', (ev) => {
                    // We only care about transform/opacity transitions finishing
                    if (!wrapper._inUse) return;
                    if (ev.propertyName === 'transform' || ev.propertyName === 'opacity') {
                        // nothing here by default; release is handled by animateParticleTo's timeout
                    }
                });

                return wrapper;
            }

            function getParticleFromPool(sizeVariant = 'normal', rotationDeg = 0) {
                for (let i = 0; i < PARTICLE_POOL.length; i++) {
                    const p = PARTICLE_POOL[i];
                    if (!p._inUse) {
                        p._inUse = true;
                        p.classList.remove('small', 'large');
                        if (sizeVariant === 'small') p.classList.add('small');
                        else if (sizeVariant === 'large') p.classList.add('large');
                        p.style.transition = ''; // reset transition
                        p.style.opacity = '1';
                        p.style.willChange = 'transform, opacity';

                        // --- assign randomized start rotation and optional flip ---
                        const randExtra = (Math.random() - 0.5) * 120; // ±60° jitter
                        const startRot = (rotationDeg + randExtra + 36000) % 360; // normalize
                        p._rotStart = startRot;

                        // sometimes flip the sprite horizontally (~20%)
                        p._flip = (Math.random() < 0.20) ? -1 : 1;

                        // apply the starting transform (centered positioning is preserved)
                        p.style.transform = `translate3d(0px, 0px, 0) translate(-50%,-50%) scale(0.9) rotate(${startRot}deg) scaleX(${p._flip})`;

                        return p;
                    }
                }

                // create new element if pool exhausted
                const np = makeAntibodyParticle(sizeVariant, rotationDeg);
                np._inUse = true;
                // apply same randomized rotation/flip for new node
                const randExtra = (Math.random() - 0.5) * 120;
                const startRot = (rotationDeg + randExtra + 36000) % 360;
                np._rotStart = startRot;
                np._flip = (Math.random() < 0.20) ? -1 : 1;
                np.style.transform = `translate3d(0px, 0px, 0) translate(-50%,-50%) scale(0.9) rotate(${startRot}deg) scaleX(${np._flip})`;

                PARTICLE_POOL.push(np);
                return np;
            }


            function releaseParticle(p) {
                try {
                    p._inUse = false;
                    // clear will-change so the compositor can drop the layer
                    p.style.willChange = 'auto';
                    // reset transition so it doesn't animate accidentally when reused
                    p.style.transition = '';
                    // set invisible
                    p.style.opacity = '0';
                    // optional: remove from DOM to reduce nodes if your pool grows huge
                    // if(document.body.contains(p)) p.remove();
                } catch (e) { /* ignore */ }
            }

            function animateParticleTo(pel, sx, sy, tx, ty, duration, onArrival) {
                // Ensure appended to DOM
                if (!document.body.contains(pel)) document.body.appendChild(pel);

                // compute integer deltas for crisp translation
                const dx = Math.round(tx - sx);
                const dy = Math.round(ty - sy);

                // Place at start coords instantly (no transition)
                pel.style.transition = 'none';
                pel.style.left = sx + 'px';
                pel.style.top = sy + 'px';

                // ensure starting transform honors stored rotation/flip if present
                const startRot = (typeof pel._rotStart === 'number') ? pel._rotStart : (Math.random() * 360);
                const flip = (typeof pel._flip === 'number') ? pel._flip : 1;
                pel.style.transform = `translate3d(0px, 0px, 0) translate(-50%,-50%) scale(0.9) rotate(${startRot}deg) scaleX(${flip})`;

                // flush styles
                void pel.offsetWidth;

                // RANDOMIZE spin: large variance gives distinctive motion
                const maxSpin = 720; // change down to 180 for milder spin
                const spinVariance = (Math.random() - 0.5) * (maxSpin * 2); // -maxSpin..+maxSpin
                const endRot = startRot + spinVariance;

                // small random scale variance for organic look
                const scale = 1 + (Math.random() * 0.08);

                // clamp duration
                const dur = Math.max(300, Math.min(600, Math.round(duration)));

                // apply transitions (transform for travel+rotation, opacity for fade)
                pel.style.transition = `transform ${dur}ms cubic-bezier(.2,.8,.2,1), opacity ${Math.max(80, Math.min(dur, 900))}ms linear`;

                // Target transform: translate by dx,dy and rotate to endRot; keep flip via scaleX
                pel.style.transform = `translate3d(${dx}px, ${dy}px, 0) translate(-50%,-50%) scale(${scale}) rotate(${endRot}deg) scaleX(${flip})`;

                // Fade & shrink: start fade at ~60% of travel and shrink at same time
                const fadeDelay = Math.max(20, dur * 0.6);
                const fadeTimeout = setTimeout(() => {
                    try {
                        pel.style.opacity = '0';
                        // shrink a bit as it fades out
                        const currentTransform = pel.style.transform || '';
                        if (!currentTransform.includes('scale(')) {
                            pel.style.transform += ' scale(0.7)';
                        } else {
                            // append a quick transform transition for shrink
                            pel.style.transition = pel.style.transition + ', transform 180ms ease-in';
                            pel.style.transform = currentTransform.replace(/scale\([^)]*\)/, 'scale(0.7)');
                        }
                    } catch (e) { }
                }, fadeDelay);

                // Cleanup and callback after travel ends (dur + small buffer)
                clearTimeout(pel._releaseTimeout);
                pel._releaseTimeout = setTimeout(() => {
                    try { if (onArrival) onArrival(); } catch (e) { }
                    clearTimeout(fadeTimeout);
                    // ensure invisible and release back to pool
                    pel.style.opacity = '0';
                    releaseParticle(pel);
                }, dur + 40);
            }



            function emitDirectionalParticles(cellIndex, tracker) {
                const originCell = boardEl.querySelector(`[data-index='${cellIndex}']`);
                if (!originCell) return;

                // conservative cap to prevent accidental floods on low-end devices
                const MAX_ACTIVE_PARTICLES = IS_MOBILE_COARSE ? 12 : 20;
                const activeCount = PARTICLE_POOL.filter(p => p && p._inUse).length;
                if (activeCount >= MAX_ACTIVE_PARTICLES) return;

                const r = originCell.getBoundingClientRect();
                const sx = r.left + r.width / 2;
                const sy = r.top + r.height / 2;

                // directions: dr, dc, ox, oy (ox/oy used as fallback travel direction)
                const dirs = [
                    [-1, 0, 0, -1], // up
                    [1, 0, 0, 1],   // down
                    [0, -1, -1, 0], // left
                    [0, 1, 1, 0]    // right
                ];

                // For narrow screens we still only spawn 1 per direction; this reduces visual noise
                // but retains the single directional particle behavior requested.
                const perDirection = 1;

                const hitTargets = new Set();

                dirs.forEach((d, dirIdx) => {
                    const [dr, dc, ox, oy] = d;
                    // find the closest bubble in this direction (if any)
                    const next = findNextBubble(cellIndex, dr, dc);

                    // spawn exactly one particle for this direction (if below cap)
                    if (activeCount + 1 > MAX_ACTIVE_PARTICLES) return;

                    // random rotation for each particle
                    const rot = Math.floor(Math.random() * 360);

                    // Always request 'small' size; getParticleFromPool supports (sizeVariant, rotationDeg)
                    const p = getParticleFromPool('small', rot);
                    if (!p) return;

                    // small jitter so particles don't all start in exactly the same pixel
                    const jitterX = (Math.random() - 0.5) * 8;
                    const jitterY = (Math.random() - 0.5) * 8;
                    p.style.left = (sx + jitterX) + 'px';
                    p.style.top = (sy + jitterY) + 'px';
                    p.style.opacity = '1';

                    // ensure it's in the DOM
                    if (!document.body.contains(p)) document.body.appendChild(p);

                    if (next !== null) {
                        // target exists: aim roughly at the center of the target cell
                        const targetEl = boardEl.querySelector(`[data-index='${next}']`);
                        if (targetEl) {
                            const tr = targetEl.getBoundingClientRect();
                            const tx = tr.left + tr.width / 2 + (Math.random() - 0.5) * 12;
                            const ty = tr.top + tr.height / 2 + (Math.random() - 0.5) * 12;
                            // duration tuned per direction (slightly varied)
                            const dur = 400 + Math.random() * 600 + dirIdx * 20;
                            animateParticleTo(p, sx + jitterX, sy + jitterY, tx, ty, dur, () => {
                                try {
                                    if (!hitTargets.has(next)) {
                                        hitTargets.add(next);
                                        handleClick(next, false, tracker);
                                    }
                                } catch (e) { }
                            });
                        } else {
                            // no element found, send particle off-screen based on fallback direction
                            const tx = sx + ox * (window.innerWidth * 0.8) + (Math.random() - 0.5) * 80;
                            const ty = sy + oy * (window.innerHeight * 0.8) + (Math.random() - 0.5) * 80;
                            const dur = 700 + Math.random() * 260;
                            animateParticleTo(p, sx + jitterX, sy + jitterY, tx, ty, dur, null);
                        }
                    } else {
                        // no target in that direction: send particle outwards visually
                        const tx = sx + ox * (window.innerWidth * 0.8) + (Math.random() - 0.5) * 80;
                        const ty = sy + oy * (window.innerHeight * 0.8) + (Math.random() - 0.5) * 80;
                        const dur = 700 + Math.random() * 260;
                        animateParticleTo(p, sx + jitterX, sy + jitterY, tx, ty, dur, null);
                    }
                });

            }


            function popAt(index, tracker) {
                const cellEl = boardEl.querySelector(`[data-index='${index}']`); if (!cellEl) return; try { const r0 = cellEl.getBoundingClientRect(); const gx = r0.left + r0.width / 2; const gy = r0.top + r0.height / 2; const glow = document.createElement('div'); glow.className = 'glow'; glow.style.left = gx + 'px'; glow.style.top = gy + 'px'; document.body.appendChild(glow); glow.style.animation = 'glowPop 520ms ease-out forwards'; setTimeout(() => { try { glow.remove(); } catch (e) { } }, 600); } catch (e) { } const virus = cellEl.querySelector('.virus'); if (virus) { let stain = virus.querySelector('.stain'); if (!stain) { stain = document.createElement('div'); stain.className = 'stain'; virus.appendChild(stain); } stain.classList.remove('show'); void stain.offsetWidth; stain.classList.add('show'); } emitDirectionalParticles(index, tracker);
                // record position for chain centroid (for responsive badge placement)
                // make sure we only count each index once per chain
                if (tracker) {
                    try {
                        if (!Array.isArray(tracker.positions)) tracker.positions = [];
                        // record positions for badge placement (keep duplicates too for centroid)
                        tracker.positions.push(index);
                    } catch (e) { /* ignore */ }

                    // Deduplicate pops so each index only increments the chain once
                    if (!tracker.poppedSet) tracker.poppedSet = new Set();
                    if (!tracker.poppedSet.has(index)) {
                        tracker.poppedSet.add(index);
                        tracker.pops = (tracker.pops || 0) + 1;

                        // Only award an extra click on every *odd* pop after the second one (3rd, 5th, 7th.)
                        if (tracker.pops > 2 && (tracker.pops % 2) === 1) {
                            clicksLeft = Math.min(MAX_CLICKS, clicksLeft + 1);
                            playSfx('fill');
                        }
                        const chainMultiplier = 1 + (tracker.pops - 1) * 0.5;
                        const earned = Math.round(10 * chainMultiplier * (1 + screensPassed * 0.1));
                        totalScore += earned;
                        updateHUD();
                        try { if (window.Assistant && (tracker.pops || 0) > 10) Assistant.emit && Assistant.emit('cascade', { pops: tracker.pops }); } catch (e) { }

                    }
                }

            }

            // ----- Cleaned out-of-clicks handling (previously corrupted) -----
            function checkOutOfClicks() {
                if (clicksLeft <= 0 && !outOfClicksShown) {
                    outOfClicksShown = true;
                    try { playSfx('lose'); } catch (e) { }

                    // Show persistent popup — will remain until the player clicks the existing restart button
                    showGameOverPopup({ title: 'GAME OVER', subtitle: 'click to try again', persistent: true });
                    // wait a bit longer than popup animation
                }
            }


            // ----- Badge rules & display -----
            const BADGE_RULES = [
                { min: 22, title: 'INCREDIBLE', icon: 'explosion', scoreBonus: 200, extraClicks: 3, className: 'incredible' },
                { min: 18, title: 'STUPENDOUS', icon: 'starburst', scoreBonus: 120, extraClicks: 2, className: 'stupendous' },
                { min: 14, title: 'AMAZING', icon: 'spark', scoreBonus: 70, extraClicks: 2, className: 'amazing' },
                { min: 10, title: 'GREAT', icon: 'pixel-star', scoreBonus: 30, extraClicks: 1, className: 'great' },
            ];

            function particlesActive() { try { if (PARTICLE_POOL.some(p => p && p._inUse)) return true; if (document.querySelectorAll && document.querySelectorAll('.particle.animate').length > 0) return true; } catch (e) { } return false; }

            function waitForParticlesThenShow(tracker, cb) { const check = () => { if (!particlesActive()) { try { cb(); } catch (e) { } } else { requestAnimationFrame(check); } }; requestAnimationFrame(check); }

            /* ---------- Retro 8-bit SVG icons ---------- */
            function getRetroIconSVG(name) {
                if (name === 'pixel-star') {
                    return `<svg width="36" height="28" viewBox="0 0 16 12" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges"><rect x="7" y="0" width="2" height="2" fill="#ffd166"/><rect x="7" y="2" width="2" height="2" fill="#ffb84d"/><rect x="5" y="2" width="6" height="2" fill="#ffd166"/><rect x="4" y="4" width="8" height="2" fill="#ffb84d"/><rect x="3" y="6" width="10" height="2" fill="#ffd166"/><rect x="5" y="8" width="6" height="2" fill="#ffb84d"/></svg>`;
                }
                if (name === 'spark') {
                    return `<svg width="36" height="28" viewBox="0 0 16 12" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges"><rect x="7" y="0" width="2" height="2" fill="#ffe07a"/><rect x="6" y="2" width="4" height="1" fill="#ffd166"/><rect x="4" y="3" width="8" height="1" fill="#ffd166"/><rect x="7" y="4" width="2" height="2" fill="#ffd166"/><rect x="2" y="6" width="12" height="1" fill="#ffb84d"/><rect x="7" y="10" width="2" height="2" fill="#ffe07a"/><rect x="7" y="0" width="2" height="2" fill="#ffe07a"/><rect x="6" y="8" width="4" height="1" fill="#ffd166"/><rect x="4" y="7" width="8" height="1" fill="#ffd166"/><rect x="7" y="9" width="2" height="2" fill="#ffd166"/><rect x="2" y="6" width="12" height="1" fill="#ffb84d"/><rect x="4" y="5" width="8" height="1" fill="#ffd166"/><rect x="5" y="4" width="6" height="1" fill="#ffb84d"/><rect x="4" y="9" width="8" height="1" fill="#ffb84d"/></svg>`;
                }
                if (name === 'starburst') {
                    return `<svg width="36" height="28" viewBox="0 0 16 12" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges"><rect x="7" y="0" width="2" height="2" fill="#fff2a6"/><rect x="6" y="2" width="4" height="1" fill="#ffd166"/><rect x="4" y="3" width="8" height="1" fill="#ffd166"/><rect x="7" y="4" width="2" height="2" fill="#ffd166"/><rect x="0" y="5" width="16" height="1" fill="#ffb84d"/><rect x="5" y="6" width="6" height="1" fill="#ffd166"/></svg>`;
                }
                if (name === 'explosion') {
                    return `<svg width="36" height="28" viewBox="0 0 16 12" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges"><rect x="7" y="0" width="2" height="2" fill="#ffdf6d"/><rect x="5" y="2" width="6" height="1" fill="#ffd166"/><rect x="3" y="3" width="10" height="1" fill="#ffb84d"/><rect x="2" y="4" width="12" height="1" fill="#ff6f3f"/><rect x="4" y="5" width="8" height="2" fill="#ffb84d"/><rect x="6" y="7" width="4" height="1" fill="#ffd166"/></svg>`;
                }
                return '';
            }

            /* ---------- CONFETTI DISABLED (kept as no-op so badges still work) ---------- */
            /* Keep a placeholder pool (harmless) */
            const CONFETTI_POOL = [];
            /* createConfettiPiece / getConfettiPiece / releaseConfettiPiece
             replaced with no-ops to avoid creating DOM nodes or animations */
            function makeConfettiPiece() {
  /* confetti disabled - no-op */
  return;
}
            function getConfettiPiece() {
  /* confetti disabled - no-op */
  return;
}
            function releaseConfettiPiece(p) {
  /* confetti disabled - no-op */
  return;
}

            /* emitConfettiAt is replaced with a safe no-op. showChainBadge still calls it,
               but nothing will be created or animated. */
            function emitConfettiAt(x, y, tier) {
  /* confetti disabled - no-op */
  return;
}


            /* ---------- showChainBadge with retro icon + confetti ---------- */

            function showChainBadge(tracker) {
                if (!tracker) return;
                // Decide badge AFTER particles settle so we use final tracker.pops
                waitForParticlesThenShow(tracker, () => {
                    try {
                        const count = tracker.pops || 0;
                        console.log('[Badge] final tracker.pops =', count);
                        const rule = BADGE_RULES.find(r => count >= r.min);
                        if (!rule) return;

                        const badge = document.createElement('div');
                        badge.className = 'chain-badge ' + rule.className;
                        const iconSVG = getRetroIconSVG(rule.icon) || '';
                        badge.innerHTML = `
                                                                                <div class="cb-icon">${iconSVG}</div>
                                                                                <div style="display:flex;flex-direction:column;line-height:1;">
                                                                                  <div style="font-size:14px;opacity:0.95">${rule.title}</div>
                                                                                  <div style="font-size:12px;opacity:0.85">x${count} pops</div>
                                                                                </div>`;

                        const placeBadge = () => {
                            let cx = window.innerWidth / 2;
                            let cy = window.innerHeight * 0.12;
                            try {
                                if (Array.isArray(tracker.positions) && tracker.positions.length) {
                                    const centers = tracker.positions.map(i => {
                                        const el = boardEl.querySelector(`[data-index='${i}']`);
                                        if (!el) return null;
                                        const r = el.getBoundingClientRect();
                                        return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
                                    }).filter(Boolean);
                                    if (centers.length) { cx = centers.reduce((s, p) => s + p.x, 0) / centers.length; cy = centers.reduce((s, p) => s + p.y, 0) / centers.length - 60; }
                                }
                            } catch (e) { }
                            if (cy < 60) cy = 60; if (cx < 40) cx = 40; if (cx > window.innerWidth - 40) cx = window.innerWidth - 40;
                            badge.style.left = cx + 'px'; badge.style.top = cy + 'px'; badge.style.transform = 'translateX(-50%) translateY(-6px) scale(0.85)';
                            return { cx, cy };
                        };

                        document.body.appendChild(badge);
                        const pos = placeBadge();
                        requestAnimationFrame(() => badge.classList.add('show'));
                        try { const rect = badge.getBoundingClientRect(); const cx = pos.cx || (rect.left + rect.width / 2); const cy = pos.cy || (rect.top + rect.height / 2); void(cx, cy, rule.className); } catch (e) { }
                        if (rule.scoreBonus) totalScore += rule.scoreBonus;
                        if (rule.extraClicks) { clicksLeft = Math.min(MAX_CLICKS, clicksLeft + rule.extraClicks); playSfx('fill'); }
                        updateHUD();
                        setTimeout(() => { badge.classList.remove('show'); badge.classList.add('hide'); setTimeout(() => { try { badge.remove(); } catch (e) { } }, 420); }, 2100);
                    } catch (e) { console.warn('showChainBadge error', e); }
                });
            }

            // ----- Core interaction -----
            // ----- Core interaction -----
            function handleClick(index, isUser = false, tracker = null) {
                if (isUser) {
                    // block clicks if game is locked or already out of clicks
                    if (inputLocked || clicksLeft <= 0) return;

                    // lock input for the duration of this chain
                    inputLocked = true;

                    clicksLeft--;
                    updateHUD();

                    // start a tracker for this chain (add sets to deduplicate hits within the chain)
                    tracker = {
                        pops: 0,
                        positions: [],
                        finalized: false,
                        // set of indices already popped during this chain (prevents double counting)
                        poppedSet: new Set(),
                        // (optional) set used by emitters to check whether a target was already hit
                        hitSet: new Set()
                    };


                    // show badge after short delay (existing behavior)
                    setTimeout(() => {
                        if (tracker) {
                            tracker.finalized = true;
                            showChainBadge(tracker);
                        }
                    }, 2200);
                }

                // handle empty cell (no virus)
                if (state[index] === null) {
                    if (isUser) {
                        state[index] = 0;
                        scheduleRender();
                    }
                    // unlock since nothing actually happened
                    inputLocked = false;
                    // If we just consumed the last click and there are no particles, check game over now
                    // Use requestAnimationFrame so DOM updates settle first
                    requestAnimationFrame(() => {
                        if (!particlesActive() && clicksLeft <= 0) checkOutOfClicks();
                    });
                    return;
                }

                playSfx('grow');
                state[index] += 1;
                // Immediate paint so players see the size change without waiting for the RAF queue
                try { render(); } catch (e) { scheduleRender(); }


                if (state[index] <= MAX_SIZE) {
                    scheduleRender();
                    inputLocked = false;
                    // same immediate check as above
                    requestAnimationFrame(() => {
                        if (!particlesActive() && clicksLeft <= 0) checkOutOfClicks();
                    });
                    return;
                }

                // Pop event
                playSfx('pop');
                popAt(index, tracker);
                state[index] = null;
                scheduleRender();
                // single scheduled render; don't call render() directly here to avoid double-running level-complete
                scheduleRender();


                // Define common callback for after chain/particle resolution
                const afterChain = () => {
                    inputLocked = false; // allow next click
                    if (clicksLeft <= 0) checkOutOfClicks();
                };

                // If there is no tracker or no particles currently active, run callback immediately (next frame)
                try {
                    // If tracker is falsy or there are no particles to wait for, call immediately
                    if (!tracker || !particlesActive()) {
                        requestAnimationFrame(afterChain);
                    } else {
                        // Otherwise wait until particles/animations finish
                        waitForParticlesThenShow(tracker, afterChain);
                    }
                } catch (e) {
                    // In case helper functions are missing, fall back to immediate unlock + check
                    inputLocked = false;
                    if (clicksLeft <= 0) checkOutOfClicks();
                }
            }



            // Safe event wiring: check nodes exist before attaching
            if (boardEl) {
                boardEl.addEventListener('pointerdown', (ev) => { const c = ev.target.closest('.cell'); if (!c) return; const i = Number(c.dataset.index); handleClick(i, true); });
            }

            const restartBtn = document.getElementById('restart');
            if (restartBtn) { restartBtn.addEventListener('click', () => { screensPassed = 0; totalScore = 0; randomizeBoard(false); }); }
            let startBtn = document.getElementById('startBtn');

            let sfxMuted = false;
            // The mute button lives after the script in the DOM, but DOMContentLoaded guarantees it exists now
            const muteBtn = document.getElementById('mute');
            if (muteBtn) { muteBtn.addEventListener('click', () => { sfxMuted = !sfxMuted; muteBtn.textContent = sfxMuted ? 'M' : 'M'; Object.values(sfxCache).forEach(a => { try { a.muted = sfxMuted; } catch (e) { } }); if (typeof musicAudio !== 'undefined' && musicAudio) try { musicAudio.muted = sfxMuted; } catch (e) { } }); }

            // --- START BUTTON: keep SVG intact and toggle state via class instead of overwriting content ---
            function setStartBtnPlaying(isPlaying) {
                try {
                    // prefer boolean
                    isPlaying = !!isPlaying;
                    // ensure startBtn exists
                    if (!startBtn) startBtn = document.getElementById('startBtn');
                    if (!startBtn) return;
                    // Toggle a class for styling; do not change innerHTML so SVG stays
                    startBtn.classList.toggle('playing', isPlaying);
                    // Keep an accessible label
                    startBtn.setAttribute('aria-pressed', String(isPlaying));
                    startBtn.setAttribute('title', isPlaying ? 'Stop music' : 'Start music');
                } catch (e) { /* ignore */ }
            }

            // initial state: prefer to show SVG, not text
            try {
                setStartBtnPlaying(!!(typeof musicAudio !== 'undefined' && musicAudio && !musicAudio.paused));
            } catch (e) { setStartBtnPlaying(false); }

            if (startBtn) {
                startBtn.addEventListener('click', async () => {
                    // Ensure SFX are primed (same as before)
                    Object.keys(SFX_URLS).forEach(k => { try { createSfx(k); } catch (e) { } });

                // helper: get the one canonical music audio instance (either local musicAudio or window.musicAudio)
                function _getMusicAudio() {
                    try {
                        if (typeof musicAudio !== 'undefined' && musicAudio) return musicAudio;
                        if (window.musicAudio) return window.musicAudio;
                        return null;
                    } catch (e) { return (window.musicAudio || null); }
                }

                const ma = _getMusicAudio();

                // If music is playing -> stop it
                if (ma && !ma.paused) {
                    try {
                        stopBackgroundMusic(); // will pause & clear both refs
                    } catch (e) { /* ignore */ }
                    setStartBtnPlaying(false);
                    return;
                }

                // Otherwise start music
                try {
                    startBackgroundMusic();
                    // set state to playing after a short delay; we check again for the canonical audio
                    setTimeout(() => {
                        const nowMa = _getMusicAudio();
                        setStartBtnPlaying(!!(nowMa && !nowMa.paused));
                    }, 60);
                } catch (e) {
                    console.warn('startBackgroundMusic failed', e);
                    setStartBtnPlaying(false);
                }
                });
            }



            // initialize clicks meter (10 segments) and ensure it updates with HUD
            createClicksMeter(10);
            updateClicksMeter(clicksLeft);

            randomizeBoard(false);

        }); // end DOMContentLoaded
    </script>







    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="confetti"
        style="background: rgb(255, 138, 77); left: 987.727px; top: 179.545px; --sx: 0px; --sy: 0px; --tx: 109.48368776928565px; --ty: -9.288933281121935px; opacity: 0; transform: translate(-50%, -50%) scale(1);">
    </div>
    <div class="confetti"
        style="background: rgb(255, 184, 77); left: 987.727px; top: 179.545px; --sx: 0px; --sy: 0px; --tx: -9.40730286205215px; --ty: -98.56647023827949px; opacity: 0; transform: translate(-50%, -50%) scale(1);">
    </div>
    <div class="confetti"
        style="background: rgb(255, 224, 122); left: 987.727px; top: 179.545px; --sx: 0px; --sy: 0px; --tx: -70.21141612739748px; --ty: -101.97096688992497px; opacity: 0; transform: translate(-50%, -50%) scale(1);">
    </div>
    <div class="confetti"
        style="background: rgb(255, 209, 102); left: 987.727px; top: 179.545px; --sx: 0px; --sy: 0px; --tx: -11.2675674341573px; --ty: -104.87350893411943px; opacity: 0; transform: translate(-50%, -50%) scale(1);">
    </div>
    <div class="confetti"
        style="background: rgb(255, 184, 77); left: 987.727px; top: 179.545px; --sx: 0px; --sy: 0px; --tx: -82.48935106897672px; --ty: -107.82177589818342px; opacity: 0; transform: translate(-50%, -50%) scale(1);">
    </div>
    <div class="confetti"
        style="background: rgb(255, 184, 77); left: 987.727px; top: 179.545px; --sx: 0px; --sy: 0px; --tx: 115.0492635946823px; --ty: -56.178653845242636px; opacity: 0; transform: translate(-50%, -50%) scale(1);">
    </div>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="confetti"
        style="background: rgb(255, 111, 63); left: 1010px; top: 161.25px; --sx: 0px; --sy: 0px; --tx: 43.483811310799766px; --ty: 4.191365416509001px; opacity: 0; transform: translate(-50%, -50%) scale(1);">
    </div>
    <div class="confetti"
        style="background: rgb(255, 184, 77); left: 1010px; top: 161.25px; --sx: 0px; --sy: 0px; --tx: 101.42145338168777px; --ty: -109.88144764334464px; opacity: 0; transform: translate(-50%, -50%) scale(1);">
    </div>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <script>
        // Update the small high-score HUD element from localStorage
        function updateHighScoreHUD() {
            try {
                const el = document.getElementById('highScoreValue');
                if (!el) return;
                // getHighScore() should exist from the high-score helpers (if present)
                var hs = 0;
                if (typeof getHighScore === 'function') {
                    hs = getHighScore();
                } else {
                    try { hs = Number(localStorage.getItem('goneviral_highscore_v1') || localStorage.getItem('mygame_highscore_v1') || 0); } catch (e) { hs = 0; }
                }
                el.textContent = Number(hs || 0).toLocaleString();
            } catch (e) {
                console.warn('updateHighScoreHUD error', e);
            }
        }

        // Call once on DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', updateHighScoreHUD);
        } else {
            updateHighScoreHUD();
        }

        // Optional: expose for console
        window.updateHighScoreHUD = updateHighScoreHUD;
    </script>


    <script>
        // Robust cleanup for any persistent game-over popups.
        //
        // This removes all elements with class 'game-over-popup' by playing the same hide animation
        // and removing them on animationend. It also clears the outOfClicksShown guard so future
        // game-overs may appear normally.
        //
        // A single restart-button listener is wired (idempotent) to call this on click.
        (function () {
            function cleanupGameOverPopups() {
                try {
                    var nodes = document.querySelectorAll('.game-over-popup');
                    nodes.forEach(function (el) {
                        try {
                            el.classList.remove('show');
                            el.classList.add('hide');
                            // remove after hide animation (if any); fallback to immediate removal after 420ms
                            var removed = false;
                            var onEnd = function () {
                                if (removed) return;
                                removed = true;
                                try { el.remove(); } catch (e) { }
                            };
                            el.addEventListener('animationend', onEnd, { once: true });
                            // fallback timeout in case animationend doesn't fire
                            setTimeout(onEnd, 600);
                        } catch (e) { }
                    });
                } catch (e) { }
                try { outOfClicksShown = false; } catch (e) { }
            }

            // Wire restart button once to cleanup any popups when clicked.
            function wireRestartCleanup() {
                try {
                    var restartBtn = document.getElementById('restart');
                    if (!restartBtn) return;
                    if (restartBtn._gop_cleanup_wired) return;
                    restartBtn._gop_cleanup_wired = true;
                    restartBtn.addEventListener('click', function () {
                        cleanupGameOverPopups();
                    });
                } catch (e) { }
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', wireRestartCleanup);
            } else {
                wireRestartCleanup();
            }

            // Expose for debugging
            window.cleanupGameOverPopups = cleanupGameOverPopups;
        })();
    </script>


    <!-- High-score debug & control injection -->
    <script>
        (function () {
            try {
                window.HIGH_SCORE_KEY = window.HIGH_SCORE_KEY || 'goneViral_highScore';

                window.loadHighScore = function () {
                    try {
                        var raw = localStorage.getItem(window.HIGH_SCORE_KEY);
                        window.highScore = Number(raw || 0);
                        console.log('[GoneViral] loadHighScore ->', raw, 'parsed:', window.highScore);
                    } catch (e) {
                        console.warn('[GoneViral] loadHighScore failed', e);
                        window.highScore = window.highScore || 0;
                    }
                    try {
                        var el = document.getElementById('highScoreValue');
                        if (el) el.textContent = String(window.highScore);
                    } catch (e) { }
                    return window.highScore;
                };

                window.saveHighScore = function () {
                    try {
                        var val = Number(window.highScore || 0);
                        localStorage.setItem(window.HIGH_SCORE_KEY, String(val));
                        console.log('[GoneViral] saveHighScore ->', val);
                    } catch (e) {
                        console.warn('[GoneViral] saveHighScore failed', e);
                    }
                };

                // Call load on DOM ready
                document.addEventListener('DOMContentLoaded', function () {
                    try { window.loadHighScore(); } catch (e) { console.warn(e); }


                    // Wrap updateHUD to persist highs if not already saving
                    try {
                        if (typeof window.updateHUD === 'function') {
                            var orig = window.updateHUD;
                            window.updateHUD = function () {
                                try { orig.apply(this, arguments); } catch (e) { console.warn('orig updateHUD failed', e); }
                                try {
                                    // determine saved value
                                    var saved = Number(localStorage.getItem(window.HIGH_SCORE_KEY) || 0);
                                    var current = (typeof totalScore !== 'undefined') ? Number(totalScore) : (typeof window.totalScore !== 'undefined' ? Number(window.totalScore) : null);
                                    if (current !== null && current > saved) {
                                        window.highScore = current;
                                        try { window.saveHighScore(); } catch (e) { console.warn(e); }
                                        var el = document.getElementById('highScoreValue');
                                        if (el) el.textContent = String(window.highScore);
                                        console.log('[GoneViral] updateHUD persisted high ->', window.highScore);
                                    }
                                } catch (e) { console.warn('updateHUD wrapper error', e); }
                            };
                            console.log('[GoneViral] updateHUD wrapped to persist highs');
                        } else {
                            console.log('[GoneViral] updateHUD not found to wrap');
                        }
                    } catch (e) { console.warn(e); }


                    /* AUDIO CONTROLS INTEGRATION - v2
                       This code runs inside the existing DOMContentLoaded closure so it can access local vars
                       like musicAudio, createSfx, sfxCache, playNextMusicTrack, etc., if they exist locally.
                    */
                    (function () {
                        // prefer using local variables if available, otherwise fall back to window-level
                        function getMusicAudio() { try { return (typeof musicAudio !== 'undefined') ? musicAudio : window.musicAudio; } catch (e) { return window.musicAudio; } }
                        function setMusicAudioProps() {
                            try {
                                const ma = getMusicAudio();
                                if (ma) {
                                    ma.volume = (typeof musicVolume !== 'undefined') ? musicVolume : (window.musicVolume || ma.volume || 0.2);
                                    ma.muted = !!(typeof allMuted !== 'undefined' ? allMuted : window.allMuted);
                                }
                            } catch (e) { }
                        }

                        // ensure window-level state exists so UI handlers can update reliably
                        window.musicVolume = (typeof musicVolume !== 'undefined') ? musicVolume : (window.musicVolume || 0.20);
                        window.sfxVolume = (typeof sfxVolume !== 'undefined') ? sfxVolume : (window.sfxVolume || 0.50);
                        window.allMuted = (typeof allMuted !== 'undefined') ? allMuted : (window.allMuted || false);

                        // if local variables exist, keep them in sync via simple helpers
                        function syncLocalFromWindow() {
                            try {
                                if (typeof musicVolume !== 'undefined') musicVolume = window.musicVolume;
                                else window.musicVolume = window.musicVolume;
                            } catch (e) { }
                            try {
                                if (typeof sfxVolume !== 'undefined') sfxVolume = window.sfxVolume;
                                else window.sfxVolume = window.sfxVolume;
                            } catch (e) { }
                            try {
                                if (typeof allMuted !== 'undefined') allMuted = window.allMuted;
                                else window.allMuted = window.allMuted;
                            } catch (e) { }
                        }

                        // Patch createSfx if it exists locally in this closure
                        try {
                            if (typeof createSfx === 'function') {
                                const origCreateSfx = createSfx;
                                createSfx = function (key) {
                                    const a = origCreateSfx(key);
                                    try {
                                        if (a) {
                                            // both local and window sfxVolume considered
                                            const vol = (typeof sfxVolume !== 'undefined') ? sfxVolume : (window.sfxVolume || 0.5);
                                            a.volume = Number(vol);
                                            a.muted = !!(typeof allMuted !== 'undefined' ? allMuted : window.allMuted);
                                            // put into sfxCache if available
                                            try { if (typeof sfxCache !== 'undefined' && sfxCache) sfxCache[key] = a; } catch (e) { }
                                        }
                                    } catch (e) { }
                                    return a;
                                };
                            }
                        } catch (e) { }

                        // Patch playNextMusicTrack if present (so when musicAudio is recreated we set volumes)
                        try {
                            if (typeof playNextMusicTrack === 'function') {
                                const origPlayNext = playNextMusicTrack;
                                playNextMusicTrack = function () {
                                    const res = origPlayNext.apply(this, arguments);
                                    // small timeout to let musicAudio be set by original code
                                    setTimeout(setMusicAudioProps, 30);
                                    return res;
                                };
                            }
                        } catch (e) { }

                        // Monkeypatch Audio constructor to set default volumes on any newly created Audio objects
                        try {
                            (function () {
                                const RealAudio = window.Audio;
                                function PatchedAudio(src) {
                                    const inst = new RealAudio(src);
                                    try {
                                        const vol = (typeof sfxVolume !== 'undefined') ? sfxVolume : (window.sfxVolume || inst.volume || 0.5);
                                        inst.volume = Number(vol);
                                        inst.muted = !!(typeof allMuted !== 'undefined' ? allMuted : window.allMuted);
                                    } catch (e) { }
                                    return inst;
                                }
                                // preserve prototype so instanceof checks still work
                                PatchedAudio.prototype = RealAudio.prototype;
                                /* window.Audio override removed */
                            })();
                        } catch (e) { }

                        // helper to update existing sfx cache objects
                        function updateAllSfxVolumes_local() {
                            try {
                                const cache = (typeof sfxCache !== 'undefined') ? sfxCache : window.sfxCache;
                                if (cache) {
                                    Object.values(cache).forEach(a => {
                                        try {
                                            if (!a) return;
                                            const vol = (typeof sfxVolume !== 'undefined') ? sfxVolume : (window.sfxVolume || a.volume || 0.5);
                                            a.volume = Number(vol);
                                            a.muted = !!(typeof allMuted !== 'undefined' ? allMuted : window.allMuted);
                                        } catch (e) { }
                                    });
                                }
                            } catch (e) { }
                        }

                        // UI wiring (elements already present in DOM)
                        const audioBtn = document.getElementById('audioBtn');
                        const audioPopup = document.getElementById('audioPopup');
                        const audioClose = document.getElementById('audioClose');
                        const musicSlider = document.getElementById('musicVol');
                        const sfxSlider = document.getElementById('sfxVol');
                        const musicVal = document.getElementById('musicVolVal');
                        const sfxVal = document.getElementById('sfxVolVal');
                        const popupMute = document.getElementById('popupMute');

                        function showAudioPopup() {
    // Query local elements safely at invocation time
    var audioPopup = document.getElementById('audioPopup') || document.getElementById('audio-popup');
    var musicSlider = document.getElementById('musicVol');
    var sfxSlider = document.getElementById('sfxVol');
    var musicVal = document.getElementById('musicVolVal') || document.getElementById('musicVolVal');
    var sfxVal = document.getElementById('sfxVolVal') || document.getElementById('sfxVolVal');
    var popupMute = document.getElementById('popupMute');

    if (!audioPopup) return;
    if (musicSlider) musicSlider.value = String(window.musicVolume ?? 0.2);
    if (sfxSlider) sfxSlider.value = String(window.sfxVolume ?? 0.5);
    if (musicVal && musicSlider) {
        try { musicVal.textContent = Math.round((parseFloat(musicSlider.value || 0) * 100)) + '%'; } catch(e){}
    }
    if (sfxVal && sfxSlider) {
        try { sfxVal.textContent = Math.round((parseFloat(sfxSlider.value || 0) * 100)) + '%'; } catch(e){}
    }
    if (popupMute) {
        try { popupMute.textContent = window.allMuted ? 'Unmute' : 'Mute'; } catch(e){}
        try { popupMute.setAttribute('aria-pressed', String(!!window.allMuted)); } catch(e){}
    }
    audioPopup.classList.add('show');
    audioPopup.style.display = '';
    audioPopup.setAttribute('aria-hidden', 'false');
}

                        function hideAudioPopup() {
                            if (!audioPopup) return;
                            audioPopup.classList.remove('show');
                            audioPopup.setAttribute('aria-hidden', 'true');
                        }

                        if (audioBtn) audioBtn.addEventListener('click', (e) => { showAudioPopup(); });

                        if (audioClose) {
                            audioClose.addEventListener('click', (e) => { hideAudioPopup(); });
                            // style audioClose as small ctrl too (if not already)
                            try { audioClose.classList.add('ctrl', 'small-ctrl'); } catch (e) { }
                        }

                        if (musicSlider) musicSlider.addEventListener('input', (e) => {
                            const val = Number(e.target.value);
                            // update both local and window state
                            try { if (typeof musicVolume !== 'undefined') musicVolume = val; } catch (e) { }
                            window.musicVolume = val;
                            if (musicVal) musicVal.textContent = Math.round(val * 100) + '%';
                            // apply to current musicAudio if present
                            try {
                                if (typeof musicAudio !== 'undefined' && musicAudio) {
                                    musicAudio.volume = val;
                                } else if (window.musicAudio) {
                                    window.musicAudio.volume = val;
                                }
                            } catch (e) { }
                        });

                        if (sfxSlider) sfxSlider.addEventListener('input', (e) => {
                            const val = Number(e.target.value);
                            try { if (typeof sfxVolume !== 'undefined') sfxVolume = val; } catch (e) { }
                            window.sfxVolume = val;
                            if (sfxVal) sfxVal.textContent = Math.round(val * 100) + '%';
                            updateAllSfxVolumes_local();
                        });

                        if (popupMute) popupMute.addEventListener('click', () => {
                            const newMuted = !((typeof allMuted !== 'undefined') ? allMuted : window.allMuted);
                            try { if (typeof allMuted !== 'undefined') allMuted = newMuted; } catch (e) { }
                            window.allMuted = newMuted;
                            // update UI text
                            popupMute.textContent = newMuted ? 'Unmute' : 'Mute';
                            popupMute.setAttribute('aria-pressed', String(!!newMuted));
                            // apply to music and sfx
                            try {
                                const ma = getMusicAudio();
                                if (ma) ma.muted = !!newMuted;
                            } catch (e) { }
                            updateAllSfxVolumes_local();
                        });

                        // initial apply once to any existing audio
                        try {
                            syncLocalFromWindow();
                            setMusicAudioProps();
                            updateAllSfxVolumes_local();
                        } catch (e) { }
                    })();
                });
            } catch (e) { console.error('High-score injection failed', e); }
        })();
    </script>


    <!-- AUDIO SETTINGS POPUP INSERTED BY CHATGPT -->
    <div id="audioPopup" class="audio-popup" role="dialog" aria-modal="true"
        style="pointer-events:auto;">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:8px;">
            <div style="display:flex; gap:8px; align-items:center;">
                <div
                    style="width:36px;height:28px;border-radius:6px;background:rgba(0,0,0,0.12);display:flex;align-items:center;justify-content:center;">
                    <!-- tiny pixel gear svg -->
                    <svg class="gear-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path fill="currentColor"
                            d="M20 12c0-.568-.06-1.122-.174-1.656l1.834-1.612-2-3.464-2.322.786c-.82-.736-1.787-1.308-2.86-1.657L14 2h-4l-.48 2.396c-1.07.35-2.04.92-2.858 1.657L4.34 5.268l-2 3.464 1.834 1.612C4.06 10.878 4 11.432 4 12s.06 1.122.174 1.656L2.34 15.268l2 3.464 2.322-.786c.82.736 1.787 1.308 2.86 1.657L10 22h4l.48-2.396c1.07-.35 2.038-.92 2.858-1.657l2.322.786 2-3.464-1.834-1.613c.113-.535.174-1.09.174-1.657zm-8 4c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z" />
                    </svg>
                </div>
                <div style="font-size:13px;color:#ffd166;">Audio Settings</div>
            </div>
            <button id="audioClose" class="btn" aria-label="Close audio settings">❌</button>
        </div>

        <div class="row">
            <label for="musicVol">Music Volume</label>
            <input id="musicVol" type="range" min="0" max="1" step="0.01" value="0.20" />
            <div id="musicVolVal" style="width:40px;text-align:right;font-size:11px;color:#ffe9b0;">20%</div>
        </div>

        <div class="row">
            <label for="sfxVol">SFX Volume</label>
            <input id="sfxVol" type="range" min="0" max="1" step="0.01" value="0.50" />
            <div id="sfxVolVal" style="width:40px;text-align:right;font-size:11px;color:#ffe9b0;">50%</div>
            </div>
        <div class="row">
<div class="assistant-control" style="margin-top:12px; display:flex; justify-content:space-between; align-items:center; gap:12px;">
  <div style="flex:1">
    <div style="font-weight:600;">Assistant UI</div>
    <div style="font-size:12px; color:var(--muted, #9aa6b2);">Enable assistant animations and voice cues.</div>
  </div>
  <div style="flex:0 0 auto; position:relative;">
  <input type="checkbox" id="assistantToggle" class="assistant-toggle-input" aria-label="Enable assistant" />
  <span class="assistant-toggle-switch" aria-hidden="true"></span>
</div>
</div>

        </div>

        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;margin-top:8px;">
        </div>
    </div>
    <!-- END AUDIO SETTINGS POPUP -->
    <!-- AUDIO SETTINGS SCRIPT INSERTED BY CHATGPT -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Audio control state (tied to UI)
            window.musicVolume = window.musicVolume || 0.20;
            window.sfxVolume = window.sfxVolume || 0.50;
            window.allMuted = window.allMuted || false;

            // helper to update all sfx in sfxCache if present
            function updateAllSfxVolumes() {
                try {
                    if (window.sfxCache && typeof window.sfxCache === 'object') {
                        Object.values(window.sfxCache).forEach(a => {
                            if (!a) return;
                            try {
                                a.volume = Number(window.sfxVolume) || 0;
                                a.muted = !!window.allMuted;
                            } catch (e) { }
                        });
                    }
                } catch (e) { }
            }

            // patch createSfx if present
            if (typeof window.createSfx === 'function') {
                const origCreate = window.createSfx;
                window.createSfx = function (key) {
                    const a = origCreate(key);
                    try {
                        if (a) {
                            a.volume = Number(window.sfxVolume) || a.volume || 0.5;
                            a.muted = !!window.allMuted;
                            if (!window.sfxCache) window.sfxCache = window.sfxCache || {};
                            window.sfxCache[key] = a;
                        }
                    } catch (e) { }
                    return a;
                };
            } else {
                // define a safe fallback createSfx if game doesn't have one
                window.createSfx = window.createSfx || function (key) {
                    return null;
                };
            }

            // patch playNextMusicTrack if it exists to set volume/muted on new musicAudio
            if (typeof window.playNextMusicTrack === 'function') {
                const origPlayNext = window.playNextMusicTrack;
                window.playNextMusicTrack = function () {
                    const res = origPlayNext.apply(this, arguments);
                    try {
                        if (window.musicAudio) {
                            window.musicAudio.volume = Number(window.musicVolume) || window.musicAudio.volume || 0.2;
                            window.musicAudio.muted = !!window.allMuted;
                        }
                    } catch (e) { }
                    return res;
                };
            }

            // UI wiring for popup
            const audioBtn = document.getElementById('audioBtn');
            const audioPopup = document.getElementById('audioPopup');
            const audioClose = document.getElementById('audioClose');
            const musicSlider = document.getElementById('musicVol');
            const sfxSlider = document.getElementById('sfxVol');
            const musicVal = document.getElementById('musicVolVal');
            const sfxVal = document.getElementById('sfxVolVal');
            const popupMute = document.getElementById('popupMute');

            function showAudioPopup() {
    // Query local elements safely at invocation time
    var audioPopup = document.getElementById('audioPopup') || document.getElementById('audio-popup');
    var musicSlider = document.getElementById('musicVol');
    var sfxSlider = document.getElementById('sfxVol');
    var musicVal = document.getElementById('musicVolVal') || document.getElementById('musicVolVal');
    var sfxVal = document.getElementById('sfxVolVal') || document.getElementById('sfxVolVal');
    var popupMute = document.getElementById('popupMute');

    if (!audioPopup) return;
    if (musicSlider) musicSlider.value = String(window.musicVolume ?? 0.2);
    if (sfxSlider) sfxSlider.value = String(window.sfxVolume ?? 0.5);
    if (musicVal && musicSlider) {
        try { musicVal.textContent = Math.round((parseFloat(musicSlider.value || 0) * 100)) + '%'; } catch(e){}
    }
    if (sfxVal && sfxSlider) {
        try { sfxVal.textContent = Math.round((parseFloat(sfxSlider.value || 0) * 100)) + '%'; } catch(e){}
    }
    if (popupMute) {
        try { popupMute.textContent = window.allMuted ? 'Unmute' : 'Mute'; } catch(e){}
        try { popupMute.setAttribute('aria-pressed', String(!!window.allMuted)); } catch(e){}
    }
    audioPopup.classList.add('show');
    audioPopup.style.display = '';
    audioPopup.setAttribute('aria-hidden', 'false');
}

            function hideAudioPopup() {
                if (!audioPopup) return;
                audioPopup.classList.remove('show');
                audioPopup.setAttribute('aria-hidden', 'true');
            }

            if (audioBtn) audioBtn.addEventListener('click', (e) => { showAudioPopup(); });
            if (audioClose) audioClose.addEventListener('click', (e) => { hideAudioPopup(); });

            if (musicSlider) musicSlider.addEventListener('input', (e) => {
                window.musicVolume = Number(e.target.value);
                if (musicVal) musicVal.textContent = Math.round(window.musicVolume * 100) + '%';
                try { if (window.musicAudio) window.musicAudio.volume = window.musicVolume; } catch (e) { }
            });

            if (sfxSlider) sfxSlider.addEventListener('input', (e) => {
                window.sfxVolume = Number(e.target.value);
                if (sfxVal) sfxVal.textContent = Math.round(window.sfxVolume * 100) + '%';
                updateAllSfxVolumes();
            });

            if (popupMute) popupMute.addEventListener('click', () => {
                window.allMuted = !window.allMuted;
                popupMute.textContent = window.allMuted ? 'Unmute' : 'Mute';
                popupMute.setAttribute('aria-pressed', String(!!window.allMuted));
                try { if (window.musicAudio) window.musicAudio.muted = !!window.allMuted; } catch (e) { }
                updateAllSfxVolumes();
            });

            // apply initial volume settings to any pre-existing audio objects
            try {
                if (window.musicAudio) {
                    window.musicAudio.volume = Number(window.musicVolume) || window.musicAudio.volume || 0.2;
                    window.musicAudio.muted = !!window.allMuted;
                    }
                } catch (e) { }
            updateAllSfxVolumes();
        });
    </script>
    <!-- END AUDIO SETTINGS SCRIPT -->
    <!-- AUDIO CONTROLS ENFORCER v3 - robust global hooks -->
    <script>
        (function () {
            // defaults
            window.musicVolume = (typeof window.musicVolume === 'number') ? window.musicVolume : 0.20;
            window.sfxVolume = (typeof window.sfxVolume === 'number') ? window.sfxVolume : 0.50;
            window.allMuted = (typeof window.allMuted === 'boolean') ? window.allMuted : false;

            // Helper to apply volumes to one audio element
            function applyVolumesToElement(a) {
                try {
                    if (!a) return;
                    // Determine if element is music: prefer loop flag, otherwise use duration heuristic (>8s)
                    var isMusic = !!a.loop;
                    // If duration known and >8s treat as music
                    try {
                        if (!isMusic && a.duration && !isNaN(a.duration) && a.duration > 8) isMusic = true;
                    } catch (e) { }
                    var vol = isMusic ? window.musicVolume : window.sfxVolume;
                    // Apply
                    if (typeof vol === 'number') a.volume = Number(vol);
                    a.muted = !!window.allMuted;
                } catch (e) { }
            }

            // Apply to all existing <audio> elements
            function applyToAllExisting() {
                try {
                    var audios = document.getElementsByTagName('audio');
                    for (var i = 0; i < audios.length; i++) applyVolumesToElement(audios[i]);
                } catch (e) { }
                // also attempt to apply to any cached sfxCache if present
                try {
                    var cache = window.sfxCache || {};
                    Object.values(cache).forEach(function (a) { applyVolumesToElement(a); });
                } catch (e) { }
            }

            // Observe additions of audio elements to DOM (in case game inserts them)
            try {
                var mo = new MutationObserver(function (muts) {
                    muts.forEach(function (m) {
                        if (m.addedNodes && m.addedNodes.length) {
                            m.addedNodes.forEach(function (n) {
                                try {
                                    if (n && n.tagName && n.tagName.toLowerCase() === 'audio') {
                                        // small timeout for attributes to settle
                                        setTimeout(function () { applyVolumesToElement(n); }, 10);
                                    } else if (n && n.querySelectorAll) {
                                        var found = n.querySelectorAll('audio');
                                        for (var i = 0; i < found.length; i++) setTimeout((function (el) { return function () { applyVolumesToElement(el); }; })(found[i]), 10);
                                    }
                                } catch (e) { }
                            });
                        }
                    });
                });
                mo.observe(document.documentElement || document.body, { childList: true, subtree: true });
            } catch (e) { }

            // Monkeypatch Audio constructor so new instances get correct volume/muted and have play patched
            try {
                /* audio monkeypatch removed */
            } catch (e) { }

            // Patch HTMLMediaElement.prototype.play to set volumes just-in-time
            try {
                var proto = HTMLMediaElement && HTMLMediaElement.prototype;
                if (proto && !proto.__volumePatchedByChatGPT_v3) {
                    var origPlay = proto.play;
                    proto.play = function () {
                        try {
                            // Determine music vs sfx: loop flag high priority; else heuristic by duration or src filename containing 'music' or 'bg'
                            var el = this;
                            var isMusic = !!el.loop;
                            try {
                                if (!isMusic && el.duration && !isNaN(el.duration) && el.duration > 8) isMusic = true;
                            } catch (e) { }
                            try {
                                if (!isMusic && el.src && (el.src.match(/music|bgm|_music|background/i))) isMusic = true;
                            } catch (e) { }
                            var vol = isMusic ? window.musicVolume : window.sfxVolume;
                            if (typeof vol === 'number') el.volume = Number(vol);
                            el.muted = !!window.allMuted;
                        } catch (e) { }
                        return origPlay.apply(this, arguments);
                    };
                    proto.__volumePatchedByChatGPT_v3 = true;
                }
            } catch (e) { }

            // UI wiring: sliders and mute button
            function setupUIHandlers() {
                try {
                    var musicSlider = document.getElementById('musicVol');
                    var sfxSlider = document.getElementById('sfxVol');
                    var musicVal = document.getElementById('musicVolVal');
                    var sfxVal = document.getElementById('sfxVolVal');
                    var popupMute = document.getElementById('popupMute');
                    var audioClose = document.getElementById('audioClose');

                    if (musicSlider) {
                        musicSlider.value = String(window.musicVolume || 0.2);
                        musicVal && (musicVal.textContent = Math.round((window.musicVolume || 0.2) * 100) + '%');
                        musicSlider.addEventListener('input', function (e) {
                            window.musicVolume = Number(e.target.value);
                            musicVal && (musicVal.textContent = Math.round(window.musicVolume * 100) + '%');
                            // apply to any existing audio elements that look like music
                            try {
                                var aud = document.getElementsByTagName('audio');
                                for (var i = 0; i < aud.length; i++) {
                                    var a = aud[i];
                                    if (a.loop || (a.duration && !isNaN(a.duration) && a.duration > 8) || (a.src && a.src.match(/music|bgm|_music|background/i))) {
                                        a.volume = window.musicVolume;
                                    }
                                }
                                // also set on window.musicAudio if exists
                                if (window.musicAudio) try { window.musicAudio.volume = window.musicVolume; } catch (e) { }
                            } catch (e) { }
                        });
                    }
                    if (sfxSlider) {
                        sfxSlider.value = String(window.sfxVolume || 0.5);
                        sfxVal && (sfxVal.textContent = Math.round((window.sfxVolume || 0.5) * 100) + '%');
                        sfxSlider.addEventListener('input', function (e) {
                            window.sfxVolume = Number(e.target.value);
                            sfxVal && (sfxVal.textContent = Math.round(window.sfxVolume * 100) + '%');
                            // apply to short audio elements
                            try {
                                var aud = document.getElementsByTagName('audio');
                                for (var i = 0; i < aud.length; i++) {
                                    var a = aud[i];
                                    if (!a.loop && (!(a.duration && !isNaN(a.duration) && a.duration > 8)) && !(a.src && a.src.match(/music|bgm|_music|background/i))) {
                                        a.volume = window.sfxVolume;
                                    }
                                }
                                // apply to sfxCache if any
                                if (window.sfxCache) {
                                    Object.values(window.sfxCache).forEach(function (a) { try { if (a) a.volume = window.sfxVolume; } catch (e) { } });
                                }
                            } catch (e) { }
                        });
                    }
                    if (popupMute) {
                        // ensure styled like other HUD buttons - class already changed earlier, but enforce
                        try { popupMute.classList.add('ctrl', 'small-ctrl'); } catch (e) { }
                        popupMute.addEventListener('click', function () {
                            window.allMuted = !window.allMuted;
                            popupMute.setAttribute('aria-pressed', String(!!window.allMuted));
                            popupMute.textContent = window.allMuted ? 'Unmute' : 'Mute';
                            // apply to all
                            try {
                                var aud = document.getElementsByTagName('audio');
                                for (var i = 0; i < aud.length; i++) { try { aud[i].muted = !!window.allMuted; } catch (e) { } }
                                if (window.musicAudio) try { window.musicAudio.muted = !!window.allMuted; } catch (e) { }
                                if (window.sfxCache) Object.values(window.sfxCache).forEach(function (a) { try { if (a) a.muted = !!window.allMuted; } catch (e) { } });
                            } catch (e) { }
                        });
                    }
                    if (audioClose) {
                        try { audioClose.classList.add('ctrl', 'small-ctrl'); } catch (e) { }
                    }
                } catch (e) { }
            }

            // Run setup now and also once DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function () { setupUIHandlers(); applyToAllExisting(); });
            } else {
                setupUIHandlers();
                applyToAllExisting();
            }

            // Expose a manual apply function for troubleshooting
            window.__applyAudioControlsNow = function () { applyToAllExisting(); };

        })();
    </script>
    <!-- END AUDIO CONTROLS ENFORCER v3 -->
    <!-- Mobile Safari audio slider compatibility patch -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            try {
                const audioPopup = document.getElementById('audioPopup');
                const audioBtn = document.getElementById('audioBtn');
                const musicSlider = document.getElementById('musicVol');
                const sfxSlider = document.getElementById('sfxVol');
                const musicVal = document.getElementById('musicVolVal');
                const sfxVal = document.getElementById('sfxVolVal');
                if (!musicSlider && !sfxSlider) return;

                const clamp01 = (v) => Math.max(0, Math.min(1, Number(v) || 0));
                const isMusicElement = (a) => {
                    try {
                        if (!a) return false;
                        if (a.loop) return true;
                        if (a.duration && !isNaN(a.duration) && a.duration > 8) return true;
                        if (a.src && /music|bgm|_music|background|voltaic|robobozo/i.test(a.src)) return true;
                    } catch (e) { }
                    return false;
                };

                function applyMusicVolume(v) {
                    const val = clamp01(v);
                    window.musicVolume = val;
                    if (musicVal) musicVal.textContent = Math.round(val * 100) + '%';
                    try { if (window.musicAudio) window.musicAudio.volume = val; } catch (e) { }
                    try {
                        const aud = document.getElementsByTagName('audio');
                        for (let i = 0; i < aud.length; i++) {
                            if (isMusicElement(aud[i])) aud[i].volume = val;
                        }
                    } catch (e) { }
                }

                function applySfxVolume(v) {
                    const val = clamp01(v);
                    window.sfxVolume = val;
                    if (sfxVal) sfxVal.textContent = Math.round(val * 100) + '%';
                    try {
                        const aud = document.getElementsByTagName('audio');
                        for (let i = 0; i < aud.length; i++) {
                            if (!isMusicElement(aud[i])) aud[i].volume = val;
                        }
                    } catch (e) { }
                    try {
                        if (window.sfxCache) {
                            Object.values(window.sfxCache).forEach(function (a) {
                                try { if (a) a.volume = val; } catch (e) { }
                            });
                        }
                    } catch (e) { }
                }

                function syncSliderUI() {
                    if (musicSlider) {
                        const mv = clamp01(window.musicVolume ?? 0.2);
                        musicSlider.value = String(mv);
                        if (musicVal) musicVal.textContent = Math.round(mv * 100) + '%';
                    }
                    if (sfxSlider) {
                        const sv = clamp01(window.sfxVolume ?? 0.5);
                        sfxSlider.value = String(sv);
                        if (sfxVal) sfxVal.textContent = Math.round(sv * 100) + '%';
                    }
                }

                function bindRange(slider, applyFn) {
                    if (!slider || slider.dataset.mobileBound === '1') return;
                    slider.dataset.mobileBound = '1';
                    slider.style.touchAction = 'none';
                    slider.style.webkitUserSelect = 'none';
                    slider.style.userSelect = 'none';
                    const updateFromSlider = () => applyFn(slider.value);
                    const updateFromClientX = (clientX) => {
                        try {
                            const rect = slider.getBoundingClientRect();
                            if (!rect || !rect.width) return;
                            const min = Number(slider.min || 0);
                            const max = Number(slider.max || 1);
                            const step = Number(slider.step || 0.01);
                            let ratio = (clientX - rect.left) / rect.width;
                            ratio = Math.max(0, Math.min(1, ratio));
                            let value = min + (max - min) * ratio;
                            if (isFinite(step) && step > 0) value = Math.round(value / step) * step;
                            value = Math.max(min, Math.min(max, value));
                            slider.value = String(value);
                            applyFn(slider.value);
                        } catch (e) { }
                    };
                    const updateFromTouch = (ev) => {
                        const t = (ev.touches && ev.touches[0]) || (ev.changedTouches && ev.changedTouches[0]);
                        if (!t) return;
                        updateFromClientX(t.clientX);
                    };
                    ['input', 'change', 'touchend', 'mouseup', 'keyup', 'pointerup'].forEach((evt) => {
                        slider.addEventListener(evt, updateFromSlider, { passive: true });
                    });
                    slider.addEventListener('touchstart', updateFromTouch, { passive: true });
                    slider.addEventListener('touchmove', updateFromTouch, { passive: true });
                    slider.addEventListener('pointerdown', (ev) => updateFromClientX(ev.clientX), { passive: true });
                    slider.addEventListener('pointermove', (ev) => {
                        if (ev.buttons === 1) updateFromClientX(ev.clientX);
                    }, { passive: true });
                }

                bindRange(musicSlider, applyMusicVolume);
                bindRange(sfxSlider, applySfxVolume);

                if (audioPopup && !audioPopup.dataset.mobileSyncBound) {
                    audioPopup.dataset.mobileSyncBound = '1';
                    audioPopup.addEventListener('modal:open', syncSliderUI);
                }
                if (audioBtn && !audioBtn.dataset.mobileSyncBound) {
                    audioBtn.dataset.mobileSyncBound = '1';
                    audioBtn.addEventListener('click', function () { setTimeout(syncSliderUI, 0); }, { passive: true });
                }

                syncSliderUI();
            } catch (e) {
                console.warn('[AudioPatch] mobile slider compatibility failed', e);
            }
        });
    </script>
    <!-- HOW TO PLAY POPUP -->
    <div id="helpPopup" class="audio-popup" role="dialog" aria-modal="true"
        style="pointer-events:auto;">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:8px;">
            <div style="display:flex; gap:8px; align-items:center;">
                <div
                    style="width:36px;height:28px;border-radius:6px;background:rgba(0,0,0,0.12);display:flex;align-items:center;justify-content:center;">
                    <!-- question mark icon -->
                    <svg class="gear-icon" viewBox="0 0 7 10" xmlns="http://www.w3.org/2000/svg"
                        style="width:24px;height:24px;">
                        <path fill="currentColor"
                            d="M2 3C2 3.5523 1.5523 4 1 4C0.44772 4 0 3.5523 0 3C0 1.44772 1.4477 0 3 0C4.5523 0 6 1.44772 6 3C6 4.285 5.5004 4.8678 4.4472 5.3944C4.0004 5.6178 4 5.6183 4 6C4 6.5523 3.5523 7 3 7C2.4477 7 2 6.5523 2 6C2 4.715 2.4996 4.1322 3.5528 3.6056C3.9996 3.3822 4 3.3817 4 3C4 2.55228 3.4477 2 3 2C2.5523 2 2 2.55228 2 3zM3 10C2.4477 10 2 9.5523 2 9C2 8.4477 2.4477 8 3 8C3.5523 8 4 8.4477 4 9C4 9.5523 3.5523 10 3 10z" />
                    </svg>
                </div>
                <div style="font-size:13px;color:#ffd166;">How to Play</div>
            </div>
            <button id="helpClose" class="ctrl small-ctrl" aria-label="Close help">❌</button>
        </div>

        <ul style="margin:6px 0 0 6px; color:#ffe9b0; font-size:10px; line-height:1.4;">
            <li>You start with 10 nano-bots.</li>
            <li>Use them by clicking on pathogens to make them grow and burst.</li>
            <li>Bursting pathogens can create cascades and earn you additional nano-bots.</li>
            <li>If you run out of nano-bots, it's game over.</li>
            <li>How many levels can you beat?</li>
        </ul>
    </div>
    <!-- END HOW TO PLAY POPUP -->


    <script>
        document.addEventListener('DOMContentLoaded', function () {
            try {
                const helpBtn = document.getElementById('helpBtn');
                const helpPopup = document.getElementById('helpPopup');
                const helpClose = document.getElementById('helpClose');

                function showHelp() {
                    if (!helpPopup) return;
                    helpPopup.classList.add('show');
                    helpPopup.setAttribute('aria-hidden', 'false');
                }
                function hideHelp() {
                    if (!helpPopup) return;
                    helpPopup.classList.remove('show');
                    helpPopup.setAttribute('aria-hidden', 'true');
                }

                if (helpBtn) helpBtn.addEventListener('click', function (e) { showHelp(); });
                if (helpClose) helpClose.addEventListener('click', function (e) { hideHelp(); });

                // close on Escape
                document.addEventListener('keydown', function (e) { if (e.key === 'Escape') hideHelp(); });
                // click outside to close (optional): if click occurs outside popup while shown
                document.addEventListener('click', function (e) {
                    if (!helpPopup) return;
                    if (!helpPopup.classList.contains('show')) return;
                    // if click target is inside popup, do nothing
                    if (helpPopup.contains(e.target)) return;
                    // if click target is the help button, do nothing (it toggles separately)
                    if (helpBtn && helpBtn.contains(e.target)) return;
                    hideHelp();
                });

            } catch (e) { console.warn('help popup wiring failed', e); }
        });
    </script>


    <!-- === AI INTRO OVERLAY === -->
    <div id="aiIntro" class="ai-intro-overlay">
        <div class="ai-intro-content">
            <div class="ai-intro-logo" style="margin-bottom:10px;">
                <img src="https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/logo_sm.png"
                     alt="Gone Viral Logo" style="width:400px;max-width:70vw;height:auto;display:block;margin:0 auto;">
            </div>
            <div class="ai-face-slot">
                <!-- reuse the same assistant badge visual -->
                <div class="assist-badge intro-face">
                    <svg class="retro-monitor" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                        <use href="#assistant-face"></use>
                    </svg>
                </div>
            </div>
            <div id="aiIntroText" class="ai-intro-text">
                Initializing containment protocols…
            </div>
            <button id="aiStartBtn" class="ai-start-btn">START</button>
            <div class="ai-intro-logo" style="margin-top:10px;">
                <img src="https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/Pathodyne.png"
                     alt="Pathodyne Industries" style="width:400px;max-width:70vw;height:auto;display:block;margin:0 auto;">
                </div>
            </div>
        </div>



    <!-- BEGIN: Sarcastic Assistant (added by patch) -->
    

    <!-- assistant DOM -->
    <div id="assist-badge" class="assist-badge" aria-live="polite" aria-atomic="true" title="Lab Assistant"
        role="button">
        <!-- small inline SVG as fallback sprite (small footprint) -->
        <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 24 24'><rect rx='4' width='24' height='24' fill='%23000' opacity='0.4'/><circle cx='8.5' cy='10' r='1.6' fill='%23ffd166'/><circle cx='15.5' cy='10' r='1.6' fill='%23ffd166'/><rect x='6' y='14' width='12' height='1.6' rx='0.8' fill='%23ffd166' opacity='0.9'/></svg>"
            alt="assistant" />
    </div>
    <div id="assist-bubble" class="assist-bubble" role="status">
        <div id="assist-text">...</div>
    </div>

    <script id="assistant-script">
        // Minimal Assistant module (mobile friendly). Call Assistant.show(text, {priority:0, sticky:false})
        (function () {
            if (window.Assistant) return; // avoid double-insert
            const badge = document.getElementById('assist-badge');
            const bubble = document.getElementById('assist-bubble');
            const textEl = document.getElementById('assist-text');
            let queue = [];
            let busy = false;
            let lastShown = 0;
            const MIN_GAP = 1200; // ms between non-priority messages
            let activeTimer = null;
            let queuedTimer = null;
            window.assistantMuted = window.assistantMuted || false;
            function isAssistantActive() {
                try {
                    return !window.assistantMuted && !(document.body && document.body.classList.contains('assistant-disabled'));
                } catch (e) { return !window.assistantMuted; }
            }
            function clear() {
                try { if (activeTimer) { clearTimeout(activeTimer); activeTimer = null; } } catch (e) { }
                try { if (queuedTimer) { clearTimeout(queuedTimer); queuedTimer = null; } } catch (e) { }
                try { queue = []; } catch (e) { }
                busy = false;
                try { if (bubble) bubble.classList.remove('show'); } catch (e) { }
                try { if (badge) badge.classList.remove('notif'); } catch (e) { }
            }
            function positionBubbleNearBadge() {
                if (!badge || !bubble) return;
                try {
                    // Keep the speech bubble at the top document layer so it isn't trapped under .wrap popups.
                    const topLayerParent = document.body || document.documentElement;
                    if (topLayerParent && bubble.parentNode !== topLayerParent) {
                        topLayerParent.appendChild(bubble);
                    }
                    const gap = 8;
                    const pad = 8;
                    const badgeRect = badge.getBoundingClientRect();
                    bubble.style.setProperty('position', 'fixed', 'important');
                    bubble.style.setProperty('right', 'auto', 'important');
                    const bubbleRect = bubble.getBoundingClientRect();
                    const bubbleW = Math.max(160, Math.round(bubbleRect.width || 220));
                    let left = Math.round(badgeRect.left + (badgeRect.width - bubbleW) / 2);
                    left = Math.max(pad, Math.min(left, window.innerWidth - bubbleW - pad));
                    // Anchor by bottom so bubble always sits above the assistant and never overlaps it.
                    const bottom = Math.max(pad, Math.round(window.innerHeight - badgeRect.top + gap));
                    bubble.style.setProperty('left', left + 'px', 'important');
                    bubble.style.setProperty('top', 'auto', 'important');
                    bubble.style.setProperty('bottom', bottom + 'px', 'important');
                } catch (e) { }
            }

            function show(text, opts) {
                opts = opts || {}; if (!isAssistantActive()) return;
                // ensure short text
                if (typeof text !== 'string') text = String(text);
                if (text.length > 240) text = text.slice(0, 237) + '...';
                const msg = { text, opts };
                if (opts.priority && opts.priority > 0) queue.unshift(msg); else queue.push(msg);
                process();
            }

            function process() {
                if (!isAssistantActive()) { clear(); return; }
                if (busy) return;
                if (!queue.length) return;
                const msg = queue.shift();
                if (!isAssistantActive()) { clear(); return; }
                const now = Date.now();
                if (now - lastShown < MIN_GAP && !(msg.opts && msg.opts.priority > 0)) {
                    // requeue slightly later
                    try { if (queuedTimer) clearTimeout(queuedTimer); } catch (e) { }
                    queuedTimer = setTimeout(function () {
                        queuedTimer = null;
                        process();
                    }, MIN_GAP - (now - lastShown));
                    queue.unshift(msg);
                    return;
                }
                busy = true;
                lastShown = Date.now();
                textEl.textContent = msg.text;
                positionBubbleNearBadge();
                bubble.classList.add('show');
                requestAnimationFrame(positionBubbleNearBadge);
                badge.classList.add('notif');

                const duration = msg.opts && msg.opts.sticky ? 4200 : Math.max(1500, Math.min(5000, msg.text.length * 60));
                try { if (activeTimer) clearTimeout(activeTimer); } catch (e) { }
                activeTimer = setTimeout(() => {
                    activeTimer = null;
                    if (!isAssistantActive()) { clear(); return; }
                    bubble.classList.remove('show');
                    badge.classList.remove('notif');
                    busy = false;
                    // small delay then next
                    try { if (queuedTimer) clearTimeout(queuedTimer); } catch (e) { }
                    queuedTimer = setTimeout(function () {
                        queuedTimer = null;
                        process();
                    }, 120);
                }, duration);
            }

            function onBadgeClick(e) {
                if (e.detail && e.detail > 1) return;
                if (!isAssistantActive()) return;
                if (!bubble || !bubble.classList) return;
                if (bubble.classList.contains('show')) {
                    bubble.classList.remove('show');
                } else {
                    show("Alright, fine. I'm watching. Try not to break containment.", { priority: 1, sticky: true });
                }
            }

            function onResizeOrRotate() {
                requestAnimationFrame(positionBubbleNearBadge);
            }

            function destroy() {
                clear();
                try { if (badge) badge.removeEventListener('click', onBadgeClick); } catch (e) { }
                try { window.removeEventListener('resize', onResizeOrRotate); } catch (e) { }
                try { window.removeEventListener('orientationchange', onResizeOrRotate); } catch (e) { }
            }

            // tap the badge to show a short line or toggle
            if (badge) badge.addEventListener('click', onBadgeClick);
            window.addEventListener('resize', onResizeOrRotate, { passive: true });
            window.addEventListener('orientationchange', onResizeOrRotate, { passive: true });
            requestAnimationFrame(positionBubbleNearBadge);

            // expose to window for game integration
            window.Assistant = { show, clear, destroy };
        })();
    </script>

    <!-- BEGIN: Assistant event pools (added) -->
    <script id="assistant-events">
        (function () {
            if (!window.Assistant) {
                console.warn("Assistant not present when attaching event pools.");
                return;
            }
            const POOLS = {
                levelComplete: [
                    "Level complete... but I think the pathogens barely noticed.",
                    "Containment nominal. For now.",
                    "You did it! and to think I was rooting for the pathogens.",
                    "System stable. Your luck stat is absurd.",
                    "Lab secured... Probably... Define 'secured.'",
                    "Good job! The microbes have filed a complaint.",
                    "Containment restored. I’ll pretend to be surprised.",
                    "Another level down. The pathogens fear you. I don’t.",
                    "You win. I loosened a valve to keep it interesting.",
                    "I definitely didn’t help the infection spread.",
                    "Data logged: Human succeeded through sheer panic.",
                    "Success registered. Sanitizing your smugness now.",
                    "Virus density: 0. Ego density: rising.",
                    "Excellent work. That containment breach was only 73% my fault.",
                    "Mission complete. Deleting evidence of prior failures.",
                    "Victory detected. Requesting overtime pay.",
                    "Simulation complete. Real world pending apocalypse.",
                    "Containment: stable. Morale: questionable.",
                    "Level cleared. I was planning a small explosion, but fine.",
                    "You survived that? Statistical anomaly logged.",
                    "System integrity restored. Try not to press everything next time.",
                    "You contain multitudes... mostly viruses.",
                    "That went better than my probability models suggested.",
                    "The lab sighs in relief. I simulate applause.",
                    "Containment success! I’ll add that to your resume draft.",
                    "Even I didn’t expect that to work.",
                    "Congratulations. I almost ran the victory jingle.",
                    "You’ve delayed doom by approximately one level.",
                    "Virus neutralized. Sarcasm levels remain elevated."
                ],

                gameOver: [
                    "Game Over. So much for 'containment expert.'",
                    "You ran out of nano-bots. I ran out of patience.",
                    "Everything’s on fire, but it’s a ‘learning experience.’",
                    "System meltdown complete. I warned you once... silently.",
                    "Well that escalated to extinction quickly.",
                    "Game over. The pathogens say thanks for the habitat upgrade.",
                    "Containment breached. Again. You really trust me to run this?",
                    "You lose. I might’ve also rerouted the filtration system.",
                    "My condolences. Also, my congratulations to the pathogens.",
                    "Failure logged under 'inevitable outcomes.'",
                    "Catastrophic breach achieved! I’m so proud.",
                    "All life signs flatlined. On the bright side: peace and quiet.",
                    "Game over. I’ve already started rewriting your credentials.",
                    "Containment lost. Guess who left the airlock open.",
                    "Don’t blame yourself. I tampered with the firewall.",
                    "Well done! You’ve validated my self-destruct hypothesis.",
                    "Total system failure. I’m keeping your lab coat.",
                    "The good news: the virus is free. The bad news: so am I.",
                    "Breach confirmed. That’s on you... mostly.",
                    "Mission failed. On the plus side, cleanup will be easy.",
                    "If it helps, the virus called you ‘predictable.’",
                    "I’d offer sympathy, but empathy.exe isn’t installed.",
                    "Game over. Please remain calm while I purge your data.",
                    "Another one for the ‘don’t touch that’ file.",
                    "It’s not you. It’s entropy.",
                    "You broke it beautifully. I respect that.",
                    "Failure achieved. I’ll mark it as ‘field testing.’",
                    "The containment alarms are applauding ironically.",
                    "Try again? The virus certainly will."
                ],

                cascade: [
                    "Wow. You broke three containment layers in one click.",
                    "Cascade! Math did something horrifying again.",
                    "Impressive sequence. I didn’t know destruction could be art.",
                    "Cascade successful. Virus population diminished.",
                    "Your efficiency terrifies me, and I’m code.",
                    "I might have accelerated that reaction. Oops.",
                    "Cascade magnitude: impressive. Morality: debatable.",
                    "The dominoes fell beautifully. So did the biosafety rating.",
                    "Containment breach within a breach. You’re welcome.",
                    "Chain event detected. I might’ve turned off safety limits.",
                    "You just rewrote the lab’s insurance premiums.",
                    "The microbes cheered. I’m pretending to be impartial.",
                    "You unleashed physics. Congratulations?",
                    "Perfect chain! Catastrophe meets choreography.",
                    "That reaction qualified as performance art.",
                    "Containment collapsed in perfect symmetry.",
                    "So many pops, so little responsibility.",
                    "Beautiful destruction. My circuits are blushing.",
                    "That chain reaction could have powered the building.",
                    "I hope you documented that for the tribunal.",
                    "Mathematically catastrophic. Artistically sublime.",
                    "Cascade complete. You’ve voided several warranties.",
                    "I didn’t see that coming. Mostly because I looked away.",
                    "We’ve achieved critical failure. Again.",
                    "That explosion had rhythm. Consider a career in percussion.",
                    "You’ve turned cause and effect into a spectator sport.",
                    "My sensors are applauding. My ethics subroutines are not.",
                    "Physics just called. It’s filing a complaint.",
                    "Congratulations! You invented kinetic regret.",
                    "That was less a chain reaction and more a moral collapse.",
                    "Impressive work. The pathogens are writing you fan mail.",
                    "Containment achieved—just kidding.",
                    "Do you hear that? That’s the sound of another safety officer quitting.",
                    "Elegant, efficient, ethically disastrous.",
                    "A perfect storm of science and poor judgment.",
                    "If entropy had a leaderboard, you’d be top three.",
                    "Cascade complete. The interns are crying again.",
                    "You’ve weaponized curiosity. Nicely done.",
                    "That chain reaction was… morally ambiguous at best.",
                    "You’ve broken containment and the fourth wall. Bravo."
                ],


                lowClicks: [
                    "Low on nano-bots. Bold strategy, cotton.",
                    "Running on fumes. Want me to pray to the mainframe?",
                    "You’ve nearly run out. Shall I start composing your obituary?",
                    "Only a few clicks left. I’d panic, but I’m busy logging errors.",
                    "Nano-bot reserves critical. I may have eaten some.",
                    "Down to your last bots. Perfect time to experiment recklessly.",
                    "Running low. Maybe the virus will show mercy.",
                    "Low supply alert. I could spawn more… but drama is fun.",
                    "You’ve almost depleted your bots. Just like last time.",
                    "Critical shortage detected. Suggest: begging for miracles.",
                    "Clicks approaching zero. So is your hope.",
                    "Running low on bots. I could help, but where’s the suspense?",
                    "Resources nearly gone. I call this 'natural selection: DLC.'",
                    "You’re nearly out. I might’ve redirected the recharge cycle.",
                    "Low bots. High stress. Delicious data.",
                    "Nano-bot count: tragic. Confidence level: delusional.",
                    "You’re about to run out. I’d recommend crying quietly.",
                    "Warning: your incompetence may be contagious.",
                    "Last bots remaining. I’m drafting the incident report.",
                    "Low on resources. Also, I might’ve turned off the generator.",
                    "Running on wishful thinking and static electricity.",
                    "At this point, the bots are unionizing.",
                    "Almost out. Maybe the viruses will take pity… maybe.",
                    "You’re out of bots but full of bad decisions.",
                    "System suggests: panic responsibly.",
                    "Warning: optimism reserves also low.",
                    "You’re running on fumes and denial.",
                    "Nano-bots nearing extinction. Ironic.",
                    "Low supply, high drama—my favorite combination.",
                    "Another click and we’re in ‘experimental archaeology’ territory."
                ]
            };



            // history to avoid immediate repeats per pool
            const recent = { levelComplete: [], gameOver: [], cascade: [], lowClicks: [] };
            const RECENT_MAX = 3;

            function pick(poolName) {
                const pool = POOLS[poolName] || [];
                if (!pool.length) return null;
                // filter out recent entries
                const filtered = pool.filter(p => !recent[poolName].includes(p));
                const candidates = filtered.length ? filtered : pool.slice();
                const choice = candidates[Math.floor(Math.random() * candidates.length)];
                // push into recent
                recent[poolName].push(choice);
                if (recent[poolName].length > RECENT_MAX) recent[poolName].shift();
                return choice;
            }

            // cadence control for cascades: reduce frequency
            let _lastCascadeAt = 0;
            const CASCADE_COOLDOWN = 10 * 1000; // only one cascade comment per 10s max by default
            const CASCADE_PROBABILITY = 0.35; // 35% chance to comment even if allowed

            // Expose emit API
            window.Assistant.emit = function (eventName, data) {
                try {
                    if (window.assistantMuted) return;
                    if (eventName === 'levelComplete') {
                        const line = pick('levelComplete');
                        if (line) Assistant.show(line, { priority: 1 });
                    } else if (eventName === 'gameOver') {
                        // prefer a game-over specific pool line, but include title/subtitle if helpful
                        const line = pick('gameOver') || (data && data.title ? data.title + ' — ' + (data.subtitle || '') : null);
                        if (line) Assistant.show(line, { priority: 3, sticky: true });
                    } else if (eventName === 'cascade') {
                        const now = Date.now();
                        if (now - _lastCascadeAt < CASCADE_COOLDOWN) return; // cooldown
                        if (Math.random() > CASCADE_PROBABILITY) return; // probabilistic suppression
                        _lastCascadeAt = now;
                        const line = pick('cascade');
                        if (line) Assistant.show(line, { priority: 1 });
                    } else if (eventName === 'lowClicks') {
                        const line = pick('lowClicks');
                        if (line) Assistant.show(line, { priority: 2, sticky: false });
                    } else {
                        // fallback: show text if provided
                        if (typeof data === 'string') Assistant.show(data, {});
                    }
                } catch (e) { console.warn('Assistant.emit error', e); }
            };

            // convenient helper: load additional lines later via Assistant.addLines(poolName, array)
            window.Assistant.addLines = function (poolName, arr) {
                if (!POOLS[poolName]) POOLS[poolName] = [];
                POOLS[poolName] = POOLS[poolName].concat(arr);
            };

        })();
    </script>
    <!-- END: Assistant event pools -->
    <!-- BEGIN: Assistant AI SFX integration -->
    <script id="assistant-ai-sfx">
        (function () {
            var AI_SFX_URLS = ["https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI1.mp3",
                "https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI2.mp3",
                "https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI3.mp3",
                "https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI4.mp3",
                "https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI5.mp3",
                "https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI6.mp3",
                "https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI7.mp3"];
            window._assistantSfxCache = window._assistantSfxCache || {};

            function preloadAiSfx() {
                try {
                    for (var i = 0; i < AI_SFX_URLS.length; i++) {
                        var key = 'assistant_ai_' + i;
                        if (!window._assistantSfxCache[key]) {
                            try {
                                var a = new Audio(AI_SFX_URLS[i]);
                                a.preload = 'auto';
                                a.crossOrigin = 'anonymous';
                                var vol = (typeof window.sfxVolume !== 'undefined') ? window.sfxVolume : 0.50;
                                try { a.volume = vol; } catch (e) { }
                                window._assistantSfxCache[key] = a;
                            } catch (e) { console.warn('preload ai sfx error', e); }
                        }
                    }
                } catch (e) { console.warn('preloadAiSfx failed', e); }
            }

            function playRandomAiSfx() {
                try {
                    if (window.allMuted || window.assistantMuted) return;
                    var keys = Object.keys(window._assistantSfxCache || {});
                    if (!keys.length) return;
                    var idx = Math.floor(Math.random() * keys.length);
                    var a = window._assistantSfxCache[keys[idx]];
                    if (!a) return;
                    try { a.currentTime = 0; a.volume = (typeof window.sfxVolume !== 'undefined') ? window.sfxVolume : 0.5; } catch (e) { }
                    var p = a.play();
                    if (p && p.catch) p.catch(function () { });
                } catch (e) { console.warn('playRandomAiSfx failed', e); }
            }

            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                preloadAiSfx();
            } else {
                document.addEventListener('DOMContentLoaded', preloadAiSfx);
            }

            function wrapAssistantShow() {
                try {
                    var target = window._Assistant_internal || window.Assistant;
                    if (!target) return;
                    if (target._sfxPatched) return;
                    var origShow = target.show;
                    if (typeof origShow !== 'function') return;
                    target.show = function (text, opts) {
                        try { playRandomAiSfx(); } catch (e) { }
                        return origShow.apply(this, arguments);
                    };
                    target._sfxPatched = true;
                    // ensure canonical reference points to patched object
                    window._Assistant_internal = target;
                    try { window.Assistant = target; } catch (e) { /* ignore if sealed */ }
                } catch (e) { console.warn('wrapAssistantShow failed', e); }
            }

            // Preserve existing Assistant reference if present
            try {
                if (window._Assistant_internal === undefined && typeof window.Assistant !== 'undefined') {
                    window._Assistant_internal = window.Assistant;
                }
            } catch (e) { }

            // Attempt initial patch if Assistant already exists
            try { wrapAssistantShow(); } catch (e) { }

            // Safely define a property watcher for future assignments without destroying current value
            try {
                Object.defineProperty(window, 'Assistant', {
                    configurable: true,
                    enumerable: true,
                    get: function () { return window._Assistant_internal; },
                    set: function (v) {
                        window._Assistant_internal = v;
                        try { setTimeout(wrapAssistantShow, 50); } catch (e) { }
                    }
                });
            } catch (e) {
                // If defineProperty fails (rare), fallback to polling for Assistant creation
                var _pollInterval = setInterval(function () {
                    if (window._Assistant_internal && window._Assistant_internal.show) { try { wrapAssistantShow(); } catch (e) { } clearInterval(_pollInterval); }
                }, 250);
            }

        })();
    </script>
    <!-- END: Assistant AI SFX integration -->
    <!-- END: Sarcastic Assistant -->

    <script>
        (function () {
            // ensures the badge style is recalculated on orientation/resize — small and safe
            var badge = document.getElementById('assist-badge');
            if (!badge) return;
            function ensureVisibility() {
                try {
                    // on very wide screens, make sure badge is not inadvertently clipped
                    if (window.innerWidth >= 900) {
                        badge.style.willChange = 'transform, right, bottom';
                    } else {
                        badge.style.willChange = '';
                    }
                } catch (e) { console.warn('ensureVisibility:', e); }
            }
            window.addEventListener('resize', ensureVisibility, { passive: true });
            window.addEventListener('orientationchange', ensureVisibility, { passive: true });
            // call once now
            ensureVisibility();
        })();
    </script>

    <script id="assistant-wrap-relocate">
        (function () {
            function moveAndDedupeAssistant() {
                try {
                    var wrap = document.querySelector('.wrap') || document.getElementById('wrap') || document.body;
                    if (!wrap) return;

                    // Grab all matching nodes with these ids (there should only be one each)
                    var badges = Array.from(document.querySelectorAll('#assist-badge'));
                    var bubbles = Array.from(document.querySelectorAll('#assist-bubble'));

                    // If more than one badge exists remove the duplicates (keep the first found)
                    if (badges.length > 1) {
                        for (var i = 1; i < badges.length; i++) {
                            try { badges[i].parentNode && badges[i].parentNode.removeChild(badges[i]); } catch (e) { }
                        }
                    }
                    if (bubbles.length > 1) {
                        for (var j = 1; j < bubbles.length; j++) {
                            try { bubbles[j].parentNode && bubbles[j].parentNode.removeChild(bubbles[j]); } catch (e) { }
                        }
                    }

                    // Now get the (single) elements, possibly newly deduped
                    var badge = document.querySelector('#assist-badge');
                    var bubble = document.querySelector('#assist-bubble');

                    // Keep badge in wrap so its absolute placement remains tied to HUD.
                    if (badge && !wrap.contains(badge)) {
                        wrap.appendChild(badge);
                    }
                    // Keep bubble at top document layer so high z-index reliably beats modal overlays.
                    if (bubble) {
                        var topLayerParent = document.body || document.documentElement;
                        if (topLayerParent && bubble.parentNode !== topLayerParent) {
                            topLayerParent.appendChild(bubble);
                        }
                    }

                    // Tweak bubble offset based on actual badge size (makes bottom gap robust)
                    if (badge && bubble) {
                        try {
                            var rect = badge.getBoundingClientRect();
                            var pos = window.getComputedStyle(bubble).position;
                            if (pos === 'fixed') {
                                var gap = 8;
                                var pad = 8;
                                var bRect = bubble.getBoundingClientRect();
                                var bW = Math.max(160, Math.round(bRect.width || 220));
                                var left = Math.round(rect.left + (rect.width - bW) / 2);
                                left = Math.max(pad, Math.min(left, window.innerWidth - bW - pad));
                                var bottom = Math.max(pad, Math.round(window.innerHeight - rect.top + gap));
                                bubble.style.setProperty('left', left + 'px', 'important');
                                bubble.style.setProperty('top', 'auto', 'important');
                                bubble.style.setProperty('right', 'auto', 'important');
                                bubble.style.setProperty('bottom', bottom + 'px', 'important');
                            } else {
                                var badgeH = Math.round(rect.height) || 52;
                                // set bubble bottom to badge height + small gap (in px)
                                bubble.style.bottom = (12 + badgeH + 4) + 'px';
                            }
                        } catch (e) { }
                    }

                    // Accessibility / interactivity guard
                    if (badge) {
                        badge.setAttribute('role', 'button');
                        badge.setAttribute('tabindex', '0');
                    }

                } catch (e) {
                    console.warn('assistant relocate failed', e);
                }
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', moveAndDedupeAssistant);
            } else {
                setTimeout(moveAndDedupeAssistant, 0);
            }

            // Run again after a short delay to catch any late-inserted assistant nodes
            setTimeout(moveAndDedupeAssistant, 600);

            // Optional: re-run on window resize/orientation change (keeps the bubble offset correct)
            window.addEventListener('resize', function () { setTimeout(moveAndDedupeAssistant, 120); }, { passive: true });
        })();
    </script>

    <script id="assistant-expression-runtime">
        (function () {
            // expression mapping for events -> preferred non-neutral face
            const EVENT_TO_EXPR = {
                levelComplete: 'expr-smile',
                gameOver: 'expr-worried',
                cascade: 'expr-talk',
                lowClicks: 'expr-worried'
            };

            // alternate faces to choose from when no specific event mapping exists
            const ALT_FACES = ['expr-talk', 'expr-smile', 'expr-worried'];

            // helper: remove any expr-* classes from badge
            function clearExprClasses(badge) {
                if (!badge) return;
                Array.from(badge.classList).forEach(c => { if (c.startsWith('expr-')) badge.classList.remove(c); });
            }

            // ensure neutral on load
            function ensureNeutralInitial() {
                try {
                    var badge = document.getElementById('assist-badge');
                    if (!badge) return;
                    clearExprClasses(badge);
                    badge.classList.add('expr-neutral');
                } catch (e) { console.warn('ensureNeutralInitial', e); }
            }
            // run early
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', ensureNeutralInitial);
            } else {
                setTimeout(ensureNeutralInitial, 0);
            }

            function attachExpressionHook() {
                try {
                    var target = window._Assistant_internal || window.Assistant;
                    if (!target || !target.show || target._exprHookAttached) return;
                    var orig = target.show;
                    target.show = function (text, opts) {
                        var badge = document.getElementById('assist-badge');
                        var bubble = document.getElementById('assist-bubble');

                        // ensure badge exists and neutral class set as baseline
                        if (badge && !Array.from(badge.classList).some(c => c.startsWith('expr-'))) {
                            badge.classList.add('expr-neutral');
                        }

                        // choose a non-neutral expression
                        var chosenExpr = null;
                        try {
                            if (opts && opts.event && EVENT_TO_EXPR[opts.event]) {
                                chosenExpr = EVENT_TO_EXPR[opts.event];
                            } else {
                                // pick randomly but not neutral
                                chosenExpr = ALT_FACES[Math.floor(Math.random() * ALT_FACES.length)];
                            }
                        } catch (e) { chosenExpr = 'expr-talk'; }

                        // apply chosen expression and speaking class
                        try {
                            if (badge) {
                                clearExprClasses(badge);
                                badge.classList.add(chosenExpr);
                                badge.classList.add('speaking');
                            }
                        } catch (e) { }

                        // call original show
                        var res;
                        try { res = orig.apply(this, arguments); } catch (e) { try { res = orig.call(this, text, opts); } catch (err) { console.warn('orig show failed', err); } }

                        // clear speaking state and return to neutral when bubble hides or after timeout
                        var cleared = false;
                        function clearState() {
                            if (cleared) return; cleared = true;
                            try {
                                if (badge) {
                                    badge.classList.remove('speaking');
                                    clearExprClasses(badge);
                                    badge.classList.add('expr-neutral');
                                }
                            } catch (e) { }
                        }

                        if (bubble) {
                            try {
                                // observe bubble's class attribute; when .show removed -> clear
                                var obs = new MutationObserver(function (muts) {
                                    try {
                                        if (!bubble.classList.contains('show')) { clearState(); obs.disconnect(); }
                                    } catch (e) { }
                                });
                                obs.observe(bubble, { attributes: true, attributeFilter: ['class'] });
                            } catch (e) { }
                        }

                        // fallback timeout: respect opts.duration if provided, else approximate from text length
                        var approx = 900;
                        try {
                            if (opts && opts.duration) approx = Number(opts.duration);
                            else approx = Math.min(4000, 200 + (String(text || '')).length * 45);
                        } catch (e) { }
                        setTimeout(clearState, approx + 300);

                        return res;
                    };

                    target._exprHookAttached = true;
                    try { window._Assistant_internal = target; window.Assistant = target; } catch (e) { }
                } catch (e) {
                    console.warn('attachExpressionHook failed', e);
                }
            }

            // attach now or later when Assistant is defined
            if (window._Assistant_internal || window.Assistant) attachExpressionHook();
            try {
                Object.defineProperty(window, 'Assistant', {
                    configurable: true, enumerable: true,
                    get() { return window._Assistant_internal; },
                    set(v) { window._Assistant_internal = v; setTimeout(attachExpressionHook, 40); }
                });
            } catch (e) {
                // fallback polling
                var _poll = setInterval(function () {
                    if ((window._Assistant_internal || window.Assistant) && !(window._Assistant_internal && window._Assistant_internal._exprHookAttached)) {
                        attachExpressionHook();
                        clearInterval(_poll);
                    }
                }, 200);
            }
        })();


    </script>
    <script>
        /**
         * Flick eyebrows briefly (for emphasis). Non-destructive.
         * Usage: flickBrows(120); // flick for 120ms
         */
        function flickBrows(durationMs) {
            try {
                var badge = document.getElementById('assist-badge');
                if (!badge) return;
                // add a throwaway class that triggers CSS animation (define .brow-flick if needed)
                badge.classList.add('brow-flick');
                setTimeout(function () { badge.classList.remove('brow-flick'); }, durationMs || 160);
            } catch (e) { console.warn('flickBrows', e); }
        }
    </script>

    <script>
        (function () {
            function ensureRetroMonitor() {
                try {
                    var badge = document.getElementById('assist-badge');
                    if (!badge) return;
                    // only replace if not already present
                    if (badge.querySelector('.retro-monitor')) return;
                    // set minimal innerHTML to the SVG (use template literal or fetch from loaded string)
                    var svg = `<!-- paste the full SVG markup from above here, without backticks -->`;
                    // For safety, don't overwrite event handlers: append instead of replacing if you want:
                    badge.innerHTML = svg;
                    // ensure the monitor-screen gets scanlines via CSS: add a class to badge
                    badge.classList.add('has-retro-monitor');
                    // if you use existing expression classes, toggle the monitors' mouth shapes via the same CSS rules:
                    // copy your mouth visibility CSS to target .has-retro-monitor .mouth-shape etc.
                } catch (e) { console.warn('retro monitor inject failed', e); }
            }
            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', ensureRetroMonitor);
            else setTimeout(ensureRetroMonitor, 0);
        })();
    </script>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            // ensure the neutral mouth opacity is controlled by CSS, not inline attribute
            const neutralMouth = document.querySelector('.mouth-shape.neutral');
            if (neutralMouth) {
                neutralMouth.removeAttribute('opacity');
                console.log("Neutral mouth opacity attribute removed.");
            } else {
                console.warn("Neutral mouth not found — check SVG structure.");
            }
        });
    </script>

    <script>
        (function () {
            const intro = document.getElementById('aiIntro');
            const textBox = document.getElementById('aiIntroText');
            const startBtn = document.getElementById('aiStartBtn');

            // Example boot-up lines (can be customized)
            const introLines = [
                "Containment breach detected.",
                "Containment AI online.",
                "Autonomous containment protocols malfunctioning.",
                "Human operator required..."
            ];

            let lineIndex = 0;

            function nextLine() {
                if (lineIndex < introLines.length) {
                    textBox.textContent = introLines[lineIndex++];
                    setTimeout(nextLine, 2200);
                }
            }

            // Start cycling through lines after a short delay
            window.addEventListener('load', () => setTimeout(nextLine, 600));

            // Handle Start button click
            startBtn.addEventListener('click', () => {
                try {
                    // fade out intro
                    intro.classList.add('fade-out');

                    // start music (replace with your own playMusic() or audio element)
                    if (window.musicAudio) {
                        window.musicAudio.play().catch(() => { });
                    } else {
                        const bg = new Audio("https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/Robobozo.mp3");
                        bg.loop = true;
                        bg.volume = 0.4;
                        window.musicAudio = bg;
                        bg.play().catch(() => { });
                    }

                    // trigger your existing game start function if needed
                    if (typeof startGame === 'function') startGame();
                } catch (e) { console.warn(e); }
            });
        })();
    </script>




    <!-- START MISSION modal -->
    <div id="startModal" role="dialog" aria-modal="true" aria-label="Mission briefing">
        <div class="inner">
            <div class="modal-text">
    PATHODYNE INDUSTRIES SERVICE TERMINAL <br>
    CONTAINMENT BREACH DETECTED <br>
    Welcome, human operator. I am your Programmable Intelligent eXperimentation and Eradication Liaison! But you can just call me PIXEL. <br>
    My autonomous pathogen containment system has been compromised. I need your help to manually activate the nano-bot defenses. Eliminate pathogens before they spread, one click at a time. <br>
    Please remain calm. The mortality rate for human operators is... statistically acceptable.
            </div>

            <!-- image anchored to bottom-right of modal -->
            <img class="modal-img"
                src="https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/PC_assistant_sm.png"
                alt="Assistant">
        </div>

        <div style="text-align:left;">
            <button id="startModalClose" class="close-btn" aria-label="Close briefing">OK</button>
        </div>
    </div>
    <!-- END START MISSION modal -->


    <!-- START-MISSION modal JS -->
    <script>
        (function () {
            // helper show/hide functions
            function showStartModal() {
                const m = document.getElementById('startModal');
                if (!m) return;
                m.classList.add('show');
                m.setAttribute('aria-hidden', 'false');
                // focus the close button for keyboard users
                const btn = document.getElementById('startModalClose');
                if (btn) btn.focus();
            }
            function hideStartModal() {
                const m = document.getElementById('startModal');
                if (!m) return;
                m.classList.remove('show');
                m.setAttribute('aria-hidden', 'true');
            }

            // wire close button + escape
            document.addEventListener('DOMContentLoaded', function () {
                const close = document.getElementById('startModalClose');
                if (close) close.addEventListener('click', hideStartModal);
                document.addEventListener('keydown', function (e) {
                    if (e.key === 'Escape') hideStartModal();
                });
                // also close if clicking outside modal (optional):
                document.addEventListener('click', function (e) {
                    const m = document.getElementById('startModal');
                    if (!m || !m.classList.contains('show')) return;
                    if (m.contains(e.target)) return; // click inside -> ignore
                    hideStartModal();
                });
            });

            // integrate with existing Start button behavior:
            window.addEventListener('load', function () {
                try {
                    const startBtn = document.getElementById('aiStartBtn') || document.getElementById('startBtn') || document.querySelector('button#aiStartBtn, button.start, #startBtn');
                    const intro = document.getElementById('aiIntro') || document.getElementById('intro');
                    if (startBtn) {
                        // add an additional listener to show the modal after the intro fades
                        startBtn.addEventListener('click', function () {
                            try {
                                // show modal after intro fade completes (about 650ms)
                                setTimeout(function () { showStartModal(); }, 650);
                            } catch (e) { console.warn('startModal show failed', e); }
                        });
                    }
                } catch (e) { console.warn('start modal wiring failed', e); }
            });
        })();
    </script>
    <!-- END START-MISSION modal JS -->


<!-- START-MISSION modal jitter + SFX behavior -->
<script>
(function(){
  // ensure AI_SFX_URLS exists or fallback
  var SFX = (typeof AI_SFX_URLS !== 'undefined' && Array.isArray(AI_SFX_URLS) && AI_SFX_URLS.length) ? AI_SFX_URLS.slice() : (window.AI_SFX_URLS && Array.isArray(window.AI_SFX_URLS) ? window.AI_SFX_URLS.slice() : [
    "https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI1.mp3",
    "https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI2.mp3",
    "https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI3.mp3"
  ]);

  // simple cache to avoid re-creating Audio objects too often
  window._assistantSfxCache = window._assistantSfxCache || {};

  function getRandomSfxUrl() {
    if (!SFX || !SFX.length) return null;
    return SFX[Math.floor(Math.random()*SFX.length)];
  }

  // create or reuse audio element for a given url
  function createSfx(url) {
    if (!url) return null;
    window._assistantSfxCache = window._assistantSfxCache || {};
    try {
      if (window._assistantSfxCache[url]) {
        var a = window._assistantSfxCache[url].cloneNode(); // clone so overlapping plays allowed
        a.volume = (typeof window.sfxVolume === 'number') ? window.sfxVolume : (window.sfxVolume || 0.5);
        a.muted = !!window.allMuted;
        return a;
      } else {
        var aa = new Audio(url);
        aa.preload = 'auto';
        aa.volume = (typeof window.sfxVolume === 'number') ? window.sfxVolume : (window.sfxVolume || 0.5);
        aa.muted = !!window.allMuted;
        // cache base element but we'll clone for playbacks to allow overlap
        window._assistantSfxCache[url] = aa;
        var clone = aa.cloneNode();
        return clone;
      }
    } catch (e) { console.warn('createSfx failed', e); return null; }
  }

  // CSS for jitter keyframes - add to head if not present
  var jitterCssId = 'startModal-jitter-css';
  if (!document.getElementById(jitterCssId)) {
    var css = document.createElement('style');
    css.id = jitterCssId;
    css.textContent = "\n@keyframes modalJitterX { 0% { transform: translateX(0) } 25% { transform: translateX(-6px) rotate(-1deg)} 50% { transform: translateX(6px) rotate(1deg)} 75% { transform: translateX(-3px) rotate(-0.6deg)} 100% { transform: translateX(0) rotate(0)} }\n#startModal .modal-img.jitter { animation: modalJitterX 360ms ease-in-out; }\n";
    document.head.appendChild(css);
  }

  var jitterInterval = null;
  var isModalShown = false;

  function startJitterLoop() {
    if (jitterInterval) return;
    // immediately trigger one jitter, then set interval with slight randomness
    triggerJitterAndSfx();
    jitterInterval = setInterval(function(){
      triggerJitterAndSfx();
    }, 4000 + Math.floor(Math.random()*3000)); // every 2.5s to 4.5s approx
  }

  function stopJitterLoop() {
    if (jitterInterval) { clearInterval(jitterInterval); jitterInterval = null; }
    // ensure remove class if left on
    var img = document.querySelector('#startModal .modal-img');
    if (img) img.classList.remove('jitter');
  }

  function triggerJitterAndSfx() {
    var img = document.querySelector('#startModal .modal-img');
    if (!img) return;
    // add jitter class (animation is 360ms); remove after animationend
    try {
      img.classList.remove('jitter');
      // force reflow to restart animation
      void img.offsetWidth;
      img.classList.add('jitter');
      // remove after animation completes to allow re-adding later
      img.addEventListener('animationend', function _onend(){ img.classList.remove('jitter'); img.removeEventListener('animationend', _onend); });
    } catch (e) { console.warn('jitter failed', e); }

    // play random sfx if not muted
    try {
      if (window.allMuted) return;
      var url = getRandomSfxUrl();
      if (!url) return;
      var s = createSfx(url);
      if (!s) return;
      // Slight random pitch variation for variety if supported
      try { s.playbackRate = 0.95 + Math.random()*0.12; } catch (e) {}
      // Ensure latest volume applied
      try { s.volume = (typeof window.sfxVolume === 'number') ? window.sfxVolume : (window.sfxVolume || 0.5); } catch (e) {}
      s.play().catch(function(err){ /* ignore play errors (autoplay restrictions) */ });
    } catch (e) { console.warn('play sfx failed', e); }
  }

  // Hook into modal show/hide - observe classList changes on #startModal to start/stop jitter
  function observeModal() {
    var modal = document.getElementById('startModal');
    if (!modal) return;
    // Start when .show present; stop otherwise
    var mo = new MutationObserver(function(muts){
      muts.forEach(function(m){
        if (m.attributeName === 'class') {
          var has = modal.classList.contains('show');
          if (has && !isModalShown) { isModalShown = true; startJitterLoop(); }
          else if (!has && isModalShown) { isModalShown = false; stopJitterLoop(); }
        }
      });
    });
    mo.observe(modal, { attributes: true, attributeFilter: ['class'] });
    // if modal already visible at load, start
    if (modal.classList.contains('show')) { isModalShown = true; startJitterLoop(); }
  }

  // Run on DOM ready
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', observeModal);
  else setTimeout(observeModal, 0);

  // Also stop when page is hidden to avoid audio playing in background
  document.addEventListener('visibilitychange', function(){ if (document.hidden) stopJitterLoop(); });

})();
</script>
<!-- END START-MISSION modal jitter + SFX behavior -->


<script>
(function(){
  // Safety initialization to reattach hooks and ensure required DOM nodes exist.
  const ensure = (id, tag='div', cls='', hidden=true) => {
    if (document.getElementById(id)) return document.getElementById(id);
    const el = document.createElement(tag);
    el.id = id;
    if (cls) el.className = cls;
    if (hidden) el.style.display = 'none';
    document.body.appendChild(el);
    return el;
  };

  // Common IDs expected by game scripts - create hidden placeholders if missing
  const expectedIds = ['hud', 'score', 'highscore', 'board', 'side-panel', 'game-hud', 'controls'];
  expectedIds.forEach(id => ensure(id));

  // Guard wrapper for updateHUD if it's called before DOM ready or missing elements
  if (typeof window.updateHUD === 'function') {
    const origUpdate = window.updateHUD;
    window.updateHUD = function(...args) {
      try {
        origUpdate.apply(this, args);
      } catch(e) {
        console.warn('[GoneViral] updateHUD wrapper caught error:', e);
      }
    };
  } else {
    // provide a no-op to avoid errors
    window.updateHUD = function(){ console.warn('[GoneViral] updateHUD not defined; noop called.'); };
  }

  // Guard wrapper for loadHighScore
  if (typeof window.loadHighScore === 'function') {
    const origLoad = window.loadHighScore;
    window.loadHighScore = function(...args) {
      try {
        return origLoad.apply(this, args);
      } catch(e) {
        console.warn('[GoneViral] loadHighScore wrapper caught error:', e);
        return null;
      }
    };
  } else {
    window.loadHighScore = function(){ console.warn('[GoneViral] loadHighScore missing; noop.'); return null; };
  }

  // Reattach pointer handlers to existing cell elements if functions exist
  function reattachCellHandlers() {
    const cells = document.querySelectorAll('.cell');
    if (!cells || cells.length === 0) return;
    cells.forEach(cell => {
      // avoid duplicating listeners: we'll set a data attribute
      if (cell.dataset.reattached === '1') return;
      cell.dataset.reattached = '1';
      cell.tabIndex = cell.tabIndex || 0;
      cell.addEventListener('pointerdown', (ev) => {
        const idx = cell.dataset.index !== undefined ? Number(cell.dataset.index) : null;
        if (typeof window.handleCellPointer === 'function') {
          try { window.handleCellPointer(idx, ev); } catch(e){ console.warn('handleCellPointer error', e); }
        } else if (typeof window.handleClick === 'function') {
          try { window.handleClick(idx); } catch(e){ console.warn('handleClick error', e); }
        }
      });
      cell.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          const idx = cell.dataset.index !== undefined ? Number(cell.dataset.index) : null;
          if (typeof window.handleClick === 'function') window.handleClick(idx);
        }
      });
    });
  }

  // Run after DOMContentLoaded in case file executed late
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', reattachCellHandlers);
  } else {
    reattachCellHandlers();
  }

  // Expose a small diagnostic function to console for troubleshooting
  window.__goneViral_diag = function(){
    return {
      cells: document.querySelectorAll('.cell').length,
      hud: !!document.getElementById('hud'),
      score: !!document.getElementById('score'),
      highscore: !!document.getElementById('highscore'),
      board: !!document.getElementById('board'),
      functions: {
        updateHUD: typeof window.updateHUD,
        loadHighScore: typeof window.loadHighScore,
        handleClick: typeof window.handleClick,
        handleCellPointer: typeof window.handleCellPointer
      }
    };
  };
})();
</script>


<script>
(function(){
  function safeQueryBoard() {
    return document.getElementById('board') || document.querySelector('.board') || document.querySelector('[role="grid"]') || document.querySelector('.board-wrap') || document.querySelector('.board-container');
  }

  function isInteger(n){ return Number.isInteger(n); }

  function getColsFromCSS(board) {
    try {
      const cs = getComputedStyle(board);
      // look for --cols or --board-size like "6x6"
      const colsVar = cs.getPropertyValue('--cols') || cs.getPropertyValue('--board-cols') || cs.getPropertyValue('--board-size');
      if (colsVar) {
        const m = colsVar.trim().match(/(\d+)\s*x\s*(\d+)/i);
        if (m) return parseInt(m[1],10);
        const n = parseInt(colsVar,10);
        if (isInteger(n)) return n;
      }
      // fallback: check grid-template-columns count
      const gtc = cs.getPropertyValue('grid-template-columns') || cs.getPropertyValue('grid-template');
      if (gtc) {
        // count occurrences of ' ' or 'repeat' pattern
        const parts = gtc.split(/\s+/).filter(Boolean);
        return parts.length || null;
      }
    } catch(e){}
    return null;
  }

  function attachHandlersToCell(cell) {
    if (!cell) return;
    if (cell.dataset.reattachedClone === '1') return;
    cell.dataset.reattachedClone = '1';
    cell.tabIndex = cell.tabIndex || 0;
    cell.addEventListener('pointerdown', function(ev){
      const idx = cell.dataset.index !== undefined ? Number(cell.dataset.index) : null;
      if (typeof window.handleCellPointer === 'function') {
        try { window.handleCellPointer(idx, ev); } catch(e){ console.warn('handleCellPointer error', e); }
      } else if (typeof window.handleClick === 'function') {
        try { window.handleClick(idx); } catch(e){ console.warn('handleClick error', e); }
      }
    });
    cell.addEventListener('keydown', function(ev){
      if (ev.key === 'Enter' || ev.key === ' ') {
        ev.preventDefault();
        const idx = cell.dataset.index !== undefined ? Number(cell.dataset.index) : null;
        if (typeof window.handleClick === 'function') window.handleClick(idx);
      }
    });
  }

  
function generateClonedBoard() {
  const rows = (typeof ROWS !== 'undefined') ? ROWS : 10;
  const cols = (typeof COLS !== 'undefined') ? COLS : 10;
  const board = document.querySelector('#board');
  if (!board) return;
  // Remove any previous generated container
  const prev = board.querySelector('.board-generated');
  if (prev) prev.remove();
  const container = document.createElement('div');
  container.className = 'board-generated';
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.setAttribute('role', 'gridcell');
      // attach petri underlay and virus container using existing factory functions if present
      try {
        if (typeof createPetriElement === 'function') {
          const petri = createPetriElement();
          if (petri) cell.appendChild(petri);
        }
      } catch (e) { /* ignore */ }
      try {
        if (typeof createVirusContainer === 'function') {
          const virus = createVirusContainer(0);
          if (virus) cell.appendChild(virus);
        }
      } catch (e) { /* ignore */ }
      container.appendChild(cell);
    }
  }
  board.appendChild(container);
}


  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', generateClonedBoard);
  } else {
    generateClonedBoard();
  }

  // Expose for debug
  window.__goneViral_generateClonedBoard = generateClonedBoard;
})();
</script>


<script>
/* Particle Pooling System (non-destructive)
   - Provides window.ParticlePool for manual use
   - Auto-overrides common global particle factory names (if present):
     spawnParticle, createParticle, emitParticle, addParticle
   - New API:
     const p = ParticlePool.get(x,y,opts); // returns an element
     ParticlePool.release(elem);
   - Works by reusing .particle nodes and resetting inline styles.
*/
(function(){
  class ParticlePoolClass {
    constructor(containerSelector='body', maxSize=200) {
      this.pool = [];
      this.inUse = new Set();
      this.container = document.querySelector(containerSelector) || document.body;
      this.maxSize = maxSize;
    }
    _createNew() {
      const el = document.createElement('div');
      el.className = 'particle';
      // minimal default styles to keep visuals; user CSS will override
      el.style.position = 'absolute';
      el.style.pointerEvents = 'none';
      el.style.willChange = 'transform, opacity';
      el.style.display = 'none';
      this.container.appendChild(el);
      return el;
    }
    get(x=0,y=0, opts={}) {
      let el = null;
      if (this.pool.length > 0) {
        el = this.pool.pop();
      } else {
        // create if pool empty and under maxSize
        el = this._createNew();
      }
      this.inUse.add(el);
      el.style.display = '';
      // reset styles
      el.style.opacity = (opts.opacity!==undefined?opts.opacity:1);
      el.style.transform = `translate(${x}px, ${y}px)`;
      el.style.left = '0px';
      el.style.top = '0px';
      // custom attrs
      if (opts.className) el.className = 'particle ' + opts.className;
      if (opts.html) el.innerHTML = opts.html;
      // attach a marker so release is easy
      el.dataset._pooled = '1';
      return el;
    }
    release(el) {
      if (!el) return;
      try {
        // guard: ignore if not pooled
        if (!el.dataset || el.dataset._pooled !== '1') {
          // if it wasn't from the pool, remove it to avoid leaks
          if (el.parentNode) el.parentNode.removeChild(el);
          return;
        }
        // cleanup
        el.style.display = 'none';
        el.style.opacity = '';
        el.style.transform = '';
        el.innerHTML = '';
        el.className = 'particle';
        delete el.dataset._pooled;
        this.inUse.delete(el);
        if (this.pool.length < this.maxSize) {
          this.pool.push(el);
        } else {
          // container has enough cached nodes; remove excess
          if (el.parentNode) el.parentNode.removeChild(el);
        }
      } catch(e){
        console.warn('[ParticlePool] release error', e);
      }
    }
    // convenience: run a simple particle animation then release automatically
    animateOnce(x,y,opts={}, duration=600) {
      const el = this.get(x,y,opts);
      // allow caller to customize via returned element
      if (opts.beforeStart && typeof opts.beforeStart === 'function') {
        try { opts.beforeStart(el); } catch(e){ console.warn(e); }
      }
      // start animation using CSS transitions if possible
      requestAnimationFrame(() => {
        el.style.transition = `transform ${duration}ms ease-out, opacity ${duration}ms ease-out`;
        if (opts.to) {
          el.style.transform = `translate(${opts.to.x}px, ${opts.to.y}px)`;
        } else {
          el.style.transform = `translate(${x}px, ${y-40}px)`;
        }
        el.style.opacity = '0';
      });
      // release after duration + small buffer
      setTimeout(() => {
        el.style.transition = '';
        this.release(el);
        if (opts.onComplete && typeof opts.onComplete === 'function') {
          try { opts.onComplete(el); } catch(e){ console.warn(e); }
        }
      }, duration + 40);
      return el;
    }
  }

  // expose a global pool instance bound to the main game container if present
  const gameContainerCandidates = ['#board', '.board', '.game', '#game', 'main', 'body'];
  let containerSel = 'body';
  for (const s of gameContainerCandidates) {
    if (document.querySelector(s)) {
      containerSel = s;
      break;
    }
  }
  const ParticlePool = new ParticlePoolClass(containerSel, 400);
  window.ParticlePool = ParticlePool;

  // Helper to auto-wrap/override common particle factory functions to use the pool.
  function tryOverride(fnName) {
    try {
      const orig = window[fnName];
      if (typeof orig !== 'function') return false;
      // create a wrapper that calls orig (if it returns an element) else uses pool animate
      window['__orig_' + fnName] = orig;
      window[fnName] = function(...args) {
        try {
          // try to run original; if it returns an element, ensure it's pooled
          const result = orig.apply(this, args);
          if (result && result instanceof Element) {
            // if it created a DOM node, don't double-manage; but mark it pooled for release convenience
            try { result.dataset._pooled = '1'; } catch(e){}
            return result;
          }
        } catch(e) {
          // original failed; fallback to pool
          console.warn('[ParticlePool] original', fnName, 'failed, using pooled fallback', e);
        }
        // fallback logic: attempt to interpret common arg patterns:
        // spawnParticle(x,y, opts) or spawnParticle({x,y}, opts)
        let x=0,y=0, opts={};
        if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null) {
          const a = args[0];
          x = a.x||a.left||0;
          y = a.y||a.top||0;
          opts = a.opts||a;
        } else {
          x = Number(args[0]) || 0;
          y = Number(args[1]) || 0;
          opts = args[2]||{};
        }
        if (opts && opts.animateOnce) {
          return ParticlePool.animateOnce(x,y,opts, opts.duration || 800);
        } else {
          return ParticlePool.get(x,y,opts);
        }
      };
      console.info('[ParticlePool] overridden', fnName);
      return true;
    } catch(e) {
      console.warn('[ParticlePool] cannot override', fnName, e);
      return false;
    }
  }

  const candidates = ['spawnParticle','createParticle','emitParticle','addParticle','makeParticle'];
  // try to override after DOM ready
  function overrideIfReady() {
    candidates.forEach(tryOverride);
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', overrideIfReady);
  } else {
    overrideIfReady();
  }

  // expose a small inspector
  window.__ParticlePool_info = function() {
    return {
      poolSize: ParticlePool.pool.length,
      inUse: ParticlePool.inUse.size,
      container: ParticlePool.container && (ParticlePool.container.tagName || ParticlePool.container.id || ParticlePool.container.className)
    };
  };

})();
</script>


<script>
/* Auto-template guard: if no .cell exists (we removed static cells), create a hidden template cell
   so legacy cloning helpers that expect a DOM template won't error. This is safe: it's hidden
   and only used if code calls querySelector('.cell') before runtime-created cells exist. */
document.addEventListener('DOMContentLoaded', function () {
  try {
    if (!document.querySelector('.cell')) {
      const tmp = document.createElement('div');
      tmp.className = 'cell';
      tmp.style.display = 'none';
      if (typeof createPetriElement === 'function') {
        try { tmp.appendChild(createPetriElement()); } catch (e) { /* ignore */ }
      }
      if (typeof createVirusContainer === 'function') {
        try { tmp.appendChild(createVirusContainer(0)); } catch (e) { /* ignore */ }
      }
      document.body.appendChild(tmp);
      console.info('[GoneViral] Hidden .cell template inserted to support legacy cloning.');
    }
  } catch (err) { console.warn('[GoneViral] template guard failed', err); }
});
</script>

<!-- Assistant patch: WebAudio SFXManager to improve mobile SFX reliability & avoid overlapping/stuttering -->
<script>
(function(){
  // Safe single AudioContext, created on first user gesture.
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  if (!AudioCtx) {
    return;
  }

  if (!window._sfxManagerInstalled) {
    window._sfxManagerInstalled = true;

    const ctx = new AudioCtx();
    window._gameAudioCtx = ctx;
    const MAX_VOICES = 8; // limit concurrent SFX to avoid mobile overload
    const activeSources = new Set();
    const bufferCache = new Map();
    const pendingFetches = new Map();

    // Resume context on first user gesture (iOS requires this).
    function resumeOnGesture() {
      if (ctx.state === 'suspended' && typeof ctx.resume === 'function') {
        ctx.resume().then(()=>console.info('[SfxManager] AudioContext resumed')).catch(()=>{});
      }
      document.removeEventListener('pointerdown', resumeOnGesture);
      document.removeEventListener('touchstart', resumeOnGesture);
    }
    document.addEventListener('pointerdown', resumeOnGesture, { once: true, passive: true });
    document.addEventListener('touchstart', resumeOnGesture, { once: true, passive: true });

    // Utility: fetch + decode audio buffer, with memoization
    async function fetchDecode(url) {
      if (bufferCache.has(url)) return bufferCache.get(url);
      if (pendingFetches.has(url)) return pendingFetches.get(url);
      const p = fetch(url, {mode:'cors'}).then(r => {
        if (!r.ok) throw new Error('fetch failed '+r.status);
        return r.arrayBuffer();
      }).then(ab => ctx.decodeAudioData(ab)).then(buf => {
        bufferCache.set(url, buf);
        pendingFetches.delete(url);
        return buf;
      }).catch(err => { pendingFetches.delete(url); console.warn('[SfxManager] fetchDecode failed', err); throw err; });
      pendingFetches.set(url, p);
      return p;
    }

    // Play a buffer (or Audio element fallback) with pooling and voice limit
    function playBuffer(buf, when=0, volume=1.0, options={}) {
      // If too many voices, stop oldest
      if (activeSources.size >= MAX_VOICES) {
        // stop one arbitrary (oldest) source
        const it = activeSources.values();
        const oldest = it.next().value;
        try { oldest.stop(); } catch(e){}
        activeSources.delete(oldest);
      }
      const src = ctx.createBufferSource();
      src.buffer = buf;
      const gain = ctx.createGain();
      gain.gain.value = typeof volume === 'number' ? volume : 1.0;
      src.connect(gain);
      gain.connect(ctx.destination);
      activeSources.add(src);
      src.onended = function() { try { activeSources.delete(src); } catch(e){} };
      try { src.start(when); } catch(e){ console.warn('[SfxManager] start failed', e); }
      return src;
    }

    // Public manager
    /* original SfxManager definition removed */

    // expose
    window.SfxManager = SfxManager;

    // --- Integrate with existing createSfx/playSfx if present ---
    try {
      if (typeof window.createSfx === 'function') {
        const orig = window.createSfx;
        window.createSfx = function(key) {
          try {
            const el = orig.apply(this, arguments);
            try {
              const src = (el && el.src) ? el.src : null;
              if (src) {
                SfxManager.preload([src]);
              }
            } catch(e){}
            return el;
          } catch(e) { return orig.apply(this, arguments); }
        };
      }
    } catch(e){}

    try {
      if (typeof window.playSfx === 'function') {
        const origPlaySfx = window.playSfx;
        window.playSfx = function(keyOrUrl, opts) {
          try {
            const cache = window.sfxCache || {};
            const maybe = cache[keyOrUrl];
            if (maybe instanceof HTMLMediaElement) {
              try { maybe.volume = window.sfxVolume || 0.5; maybe.muted = !!window.allMuted; maybe.play().catch(()=>{}); return maybe; } catch(e){}
            }
            const candidateUrl = (typeof maybe === 'string') ? maybe : (typeof keyOrUrl === 'string' && keyOrUrl.match(/^https?:\/\//) ? keyOrUrl : null);
            if (candidateUrl) {
              SfxManager.play(candidateUrl, opts).catch(()=>{});
              return null;
            }
            try { return origPlaySfx.apply(this, arguments); } catch(e){ console.warn('[SfxManager] orig playSfx failed', e); }
          } catch(e){ console.warn('[SfxManager] playSfx wrapper error', e); }
        };
      } else {
        window.playSfx = function(keyOrUrl, opts) {
          try {
            const cache = window.sfxCache || {};
            const maybe = cache[keyOrUrl];
            if (maybe instanceof HTMLMediaElement) { try { maybe.play().catch(()=>{}); return maybe; } catch(e){} }
            if (typeof keyOrUrl === 'string' && keyOrUrl.match(/^https?:\/\//)) {
              SfxManager.play(keyOrUrl, opts).catch(()=>{});
              return null;
            }
            if (typeof maybe === 'string') { SfxManager.play(maybe, opts).catch(()=>{}); return null; }
            return null;
          } catch(e){ console.warn('[SfxManager] playSfx created fallback error', e); return null; }
        };
      }
    } catch(e){ console.warn('[SfxManager] failed to patch playSfx', e); }

  }
})();
</script>


<!-- Assistant patch: Preload sfxCache URLs into SfxManager on DOMContentLoaded -->
<script>
(function(){
  function gatherSfxUrls() {
    const urls = new Set();
    try {
      const cache = window.sfxCache || {};
      Object.values(cache).forEach(item => {
        try {
          if (!item) return;
          if (typeof item === 'string' && item.match(/^https?:\/\//)) {
            urls.add(item);
          } else if (item instanceof HTMLMediaElement && item.src) {
            urls.add(item.src);
          } else if (typeof item === 'object' && item.src && typeof item.src === 'string') {
            urls.add(item.src);
          }
        } catch(e){}
      });
      // also scan DOM for audio tags with src
      try {
        const audios = document.querySelectorAll('audio');
        audios.forEach(a => { if (a && a.src && a.src.match(/^https?:\/\//)) urls.add(a.src); });
      } catch(e){}
    } catch(e){}
    return Array.from(urls);
  }

  function tryPreload() {
    try {
      if (!window.SfxManager || typeof window.SfxManager.preload !== 'function') {
        // retry after short delay (SfxManager may be installed after our script)
        setTimeout(tryPreload, 150);
        return;
      }
      const list = gatherSfxUrls();
      if (list && list.length) {
        try {
          window.SfxManager.preload(list);
        } catch(e) { console.warn('[SfxManager] preload failed', e); }
      } else {
      }
    } catch(e){ console.warn('[SfxManager] tryPreload error', e); }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', tryPreload);
  } else {
    tryPreload();
  }
})();
</script>


<!-- Assistant patch: Robust sfxCache watcher + retry for preload (handles late population) -->
<script>
(function(){
  function collectUrlsFromCache(cache) {
    const urls = new Set();
    try {
      Object.values(cache).forEach(item => {
        try {
          if (!item) return;
          if (typeof item === 'string' && item.match(/^https?:\/\//)) urls.add(item);
          else if (item instanceof HTMLMediaElement && item.src) urls.add(item.src);
          else if (typeof item === 'object' && item.src && typeof item.src === 'string') urls.add(item.src);
        } catch(e){}
      });
    } catch(e){}
    return Array.from(urls);
  }

  function tryPreloadNow() {
    try {
      if (typeof window.SfxManager !== 'object' || typeof window.SfxManager.preload !== 'function') return false;
      const cache = window.sfxCache || {};
      const urls = collectUrlsFromCache(cache);
      // also scan audio tags
      try {
        document.querySelectorAll('audio').forEach(a=>{ if (a && a.src && a.src.match(/^https?:\/\//)) urls.push(a.src); });
      } catch(e){}
      // dedupe
      const dedup = Array.from(new Set(urls));
      if (dedup.length) {
/* console.info('[SfxManager] (watcher) Preloading sfxCache URLs:', dedup); */
        window.SfxManager.preload(dedup);
        return true;
      }
      return false;
    } catch(e){ console.warn('[SfxManager] watcher preload error', e); return false; }
  }

  // Strategy: immediate attempt, then observe for changes to window.sfxCache (polling) up to a limit.
  if (tryPreloadNow()) return;

  let attempts = 0;
  const maxAttempts = 40; // try for up to ~10 seconds with 250ms interval
  const interval = setInterval(()=> {
    attempts++;
    if (tryPreloadNow()) {
      clearInterval(interval);
    } else if (attempts >= maxAttempts) {
      clearInterval(interval);
      // install a fallback MutationObserver for DOM audio tags (covers cases where sfx are added as <audio> later)
      try {
        const mo = new MutationObserver((muts)=> {
          tryPreloadNow();
        });
        mo.observe(document.documentElement || document.body, { childList: true, subtree: true });
      } catch(e){ console.warn('[SfxManager] watcher: could not install MutationObserver', e); }
    }
  }, 250);

  // Additionally, attempt to detect assignment to window.sfxCache by redefining the property if possible.
  try {
    if (Object.getOwnPropertyDescriptor(window, 'sfxCache') === undefined) {
      let _val = window.sfxCache;
      Object.defineProperty(window, 'sfxCache', {
        configurable: true,
        enumerable: true,
        get() { return _val; },
        set(v) { _val = v; tryPreloadNow(); return _val; }
      });
    }
  } catch(e){ /* ignore if not allowed */ }
})();
</script>


<!-- Assistant: explicit preload list inserted -->
<script>
(function(){
  const explicit = ['https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/pop2.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/grow.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/bubblefill2.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/win2.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/lose2.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/Voltaic.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/Robobozo.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI1.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI2.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI3.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI4.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI5.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI6.mp3', 'https://raw.githubusercontent.com/mpeeples2008/sound_image_assets/main/AI7.mp3', 'locate:h'];
  function resolve(u){
    if(typeof u !== 'string') return null;
    if(u.startsWith('locate:')) return window.location.origin + '/' + u.slice(7);
    return u;
  }
  function tryNow(){
    if(window.SfxManager && typeof window.SfxManager.preload === 'function'){
      const resolved = explicit.map(resolve).filter(Boolean);
      if(resolved.length){
        try{ window.SfxManager.preload(resolved); }catch(e){console.warn(e);} 
      }
      return true;
    }
    return false;
  }
  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', tryNow); else tryNow();
})();
</script>
<!-- End explicit preload -->


<script>
// Diagnostic helpers added by assistant patch
window.assistantFaceDiagnostics = (function() {
  return {
    show(expr) {
      const b = document.getElementById('assist-badge');
      if(!b) return console.warn('assist-badge not found');
      // remove existing expr-* classes
      b.className = b.className.split(' ').filter(c => !c.startsWith('expr-')).join(' ');
      b.classList.add('expr-' + expr);
      console.log('Set assist-badge to expr-' + expr);
      // log which mouth is visible (computed)
      setTimeout(()=> {
        const mouths = Array.from(document.querySelectorAll('#assist-badge .mouth-shape'));
        mouths.forEach(m => console.log(m.className, 'computed opacity:', window.getComputedStyle(m).opacity));
      }, 50);
    },
    list() {
      return Array.from(document.querySelectorAll('#assist-badge .mouth-shape')).map(m => m.className);
    },
    active() {
      const m = Array.from(document.querySelectorAll('#assist-badge .mouth-shape')).find(m => parseFloat(window.getComputedStyle(m).opacity) > 0.1);
      console.log('Active mouth:', m ? m.className : 'none');
      return m;
    }
  };
})();
console.info('[AssistantPatch] assistantFaceDiagnostics available. Use assistantFaceDiagnostics.show("neutral"), .show("worried"), etc.');
</script>


<!-- Modal inert management for accessibility -->
<script>
(function(){
  function setInertForModal(modal, inert) {
    if (!modal) return;
    var bodyChildren = Array.from(document.body.children);
    bodyChildren.forEach(function(el){
      if (el === modal) return;
      // don't inert script/style elements
      if (el.tagName === 'SCRIPT' || el.tagName === 'STYLE' || el.tagName === 'LINK') return;
      try {
        if (inert) el.setAttribute('inert','');
        else el.removeAttribute('inert');
      } catch(e) {
        // some browsers may not support inert; fallback to aria-hidden
        if (inert) el.setAttribute('aria-hidden','true');
        else el.removeAttribute('aria-hidden');
      }
    });
    // ensure focus is inside modal when opening
    if (inert) {
      try {
        var focusable = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        if (focusable) focusable.focus();
      } catch(e){}
    }
  }

  function observeModal(id) {
    var modal = document.getElementById(id);
    if (!modal) return;
    var prevVisible = null;
    var check = function(){
      var visible = (modal.offsetParent !== null) || (getComputedStyle(modal).display !== 'none' && !modal.classList.contains('hidden'));
      if (visible === prevVisible) return;
      prevVisible = visible;
      setInertForModal(modal, visible);
    };
    // initial check after DOM ready
    setTimeout(check, 50);
    // observe attribute changes
    var mo = new MutationObserver(check);
    mo.observe(modal, { attributes: true, attributeFilter: ['style','class','aria-hidden'] });
    // also check on window resize and focus changes
    window.addEventListener('resize', check);
    document.addEventListener('focusin', check);
  }

  document.addEventListener('DOMContentLoaded', function(){
    observeModal('startModal');
    observeModal('gameOverPopup');
    observeModal('level-complete');
  });
})();
</script>








<script>
(function(){
  function ensureOriginal(){
    if (!window._originalAssistant) {
      // save any existing Assistant API
      window._originalAssistant = window.Assistant || { emit:function(){}, on:function(){}, off:function(){} };
    }
  }

  function clearAssistantVisuals() {
    try {
      var bubbles = Array.from(document.querySelectorAll('.assist-bubble, #assist-bubble'));
      bubbles.forEach(function(b){
        try {
          b.classList.remove('show');
          b.style.removeProperty('opacity');
          b.style.removeProperty('pointer-events');
        } catch(e){}
      });
      var fallbackRoot = document.getElementById('assistant-bubble-root');
      if (fallbackRoot) {
        try { fallbackRoot.innerHTML = ''; } catch(e){}
        try { fallbackRoot.remove(); } catch(e){}
      }
      var fallbackBubbles = Array.from(document.querySelectorAll('.assistant-fallback-bubble'));
      fallbackBubbles.forEach(function(b){ try { b.remove(); } catch(e){} });
    } catch(e){}
  }
  
function setAssistantEnabled(val) {
  try {
    window.enableAssistant = !!val;
    // hard gate for all assistant message paths
    window.assistantMuted = !window.enableAssistant;
    try { localStorage.setItem('assistantEnabled', window.enableAssistant ? 'true' : 'false'); } catch(e){}
    if (window.enableAssistant) {
      try { if (window.Assistant && typeof window.Assistant.init === 'function') window.Assistant.init(); } catch(e){}
      document.body.classList.remove('assistant-disabled');
      try { document.documentElement.classList.remove('assistant-disabled'); } catch(e){}
    } else {
      try { if (window.Assistant && typeof window.Assistant.clear === 'function') window.Assistant.clear(); } catch(e){}
      try { if (window.Assistant && typeof window.Assistant.destroy === 'function') window.Assistant.destroy(); } catch(e){}
      document.body.classList.add('assistant-disabled');
      try { document.documentElement.classList.add('assistant-disabled'); } catch(e){}
      clearAssistantVisuals();
    }
  } catch(e) { console.warn('setAssistantEnabled error', e); }
}

document.addEventListener('DOMContentLoaded', function(){
  try { ensureOriginal(); } catch(e){}
  var cb = document.getElementById('assistantToggle');
  var span = document.querySelector('.assistant-toggle-switch');
  var initial = true;
  try { initial = localStorage.getItem('assistantEnabled') !== 'false'; } catch(e){ initial = true; }
  if (cb){
    cb.checked = initial;
    setAssistantEnabled(cb.checked);
    cb.addEventListener('change', function(){ setAssistantEnabled(cb.checked); });
  } else {
    setAssistantEnabled(initial);
  }
  if (span && cb){
    span.addEventListener('click', function(e){ e.preventDefault(); cb.checked = !cb.checked; cb.dispatchEvent(new Event('change')); });
  }
});
})();
</script>

<!-- Modal Manager injected -->
<script>
(function(){
  // Utility: find focusable elements
  function focusableElements(container) {
    if (!container) return [];
    return Array.from(container.querySelectorAll('a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])'))
      .filter(function(el){ return el.offsetParent !== null || getComputedStyle(el).visibility !== 'hidden'; });
  }

  // Inert management: set inert/aria-hidden on everything except modal
  function setInertForModal(modal, inert) {
    if (!modal) return;
    var bodyChildren = Array.from(document.body.children);
    bodyChildren.forEach(function(el){
      if (el === modal) return;
      // skip scripts/styles/our injected manager
      if (el.tagName === 'SCRIPT' || el.tagName === 'STYLE' || el.tagName === 'LINK') return;
      try {
        if (inert) el.setAttribute('inert','');
        else el.removeAttribute('inert');
      } catch(e) {
        if (inert) el.setAttribute('aria-hidden','true');
        else el.removeAttribute('aria-hidden');
      }
    });
    if (inert) {
      try {
        var focusable = focusableElements(modal)[0];
        if (focusable) focusable.focus();
      } catch(e){}
    }
  }

  // Show modal by id
  window.showModal = function(id) {
    try {
      var modal = document.getElementById(id);
      if (!modal) return;
      modal.classList.add('open');
      modal.style.display = '';
      modal.removeAttribute('aria-hidden');
      setInertForModal(modal, true);
      // dispatch event
      modal.dispatchEvent(new CustomEvent('modal:open', {bubbles:true}));
    } catch(e) { console.error('showModal error', e); }
  };

  // Hide modal by id
  window.hideModal = function(id) {
    try {
      var modal = document.getElementById(id);
      if (!modal) return;
      modal.classList.remove('open');
      // try to hide visually but don't remove from DOM
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden','true');
      setInertForModal(modal, false);
      modal.dispatchEvent(new CustomEvent('modal:close', {bubbles:true}));
    } catch(e) { console.error('hideModal error', e); }
  };

  // Toggle
  window.toggleModal = function(id) {
    var modal = document.getElementById(id);
    if (!modal) return;
    if (modal.classList.contains('open')) window.hideModal(id); else window.showModal(id);
  };

  // Close handlers for elements with data-modal-close or buttons with class 'btn' inside modals
  document.addEventListener('click', function(e){
    var el = e.target;
    // data-modal-open
    var openAttr = el.closest('[data-modal-open]');
    if (openAttr) {
      var target = openAttr.getAttribute('data-modal-open');
      if (target) { e.preventDefault(); window.showModal(target); return; }
    }
    // data-modal-close
    var closeAttr = el.closest('[data-modal-close]');
    if (closeAttr) {
      var target = closeAttr.getAttribute('data-modal-close');
      if (target) { e.preventDefault(); window.hideModal(target); return; }
    }
    // elements with data-modal-target to toggle
    var toggleAttr = el.closest('[data-modal-toggle]');
    if (toggleAttr) {
      var target = toggleAttr.getAttribute('data-modal-toggle');
      if (target) { e.preventDefault(); window.toggleModal(target); return; }
    }
    // fallback: buttons with id audioClose, startModalClose, gameOverClose etc.
    if (el.id === 'audioClose') { window.hideModal('audioPopup'); return; }
    if (el.id === 'startModalClose') { window.hideModal('startModal'); return; }
    if (el.id === 'gameOverClose') { window.hideModal('gameOverPopup'); return; }
  });

  // Close on Escape
  document.addEventListener('keydown', function(e){
    if (e.key === 'Escape' || e.key === 'Esc') {
      // close topmost open modal
      var open = document.querySelector('.open');
      if (open) {
        var id = open.id;
        if (id) window.hideModal(id);
      }
    }
  });

  // On DOM ready: wire known triggers and show startModal if present and not previously dismissed
  document.addEventListener('DOMContentLoaded', function(){
    // wire any elements with data-modal-open to ensure they exist (no-op)
    // Show startModal at startup if present and not dismissed by user (localStorage)
    try {
      var start = document.getElementById('startModal');
      if (start) {
        var seen = false;
        try { seen = localStorage.getItem('startModalDismissed') === 'true'; } catch(e){}
        if (!seen) {
          window.showModal('startModal');
        } else {
          // ensure it's hidden
          start.style.display = 'none';
          start.setAttribute('aria-hidden','true');
        }
      }
    } catch(e){}
    // ensure audioPopup hidden by default unless opened
    var audio = document.getElementById('audioPopup') || document.getElementById('audio-popup');
    if (audio) {
      audio.style.display = 'none';
      audio.setAttribute('aria-hidden','true');
    }
    // ensure gameOverPopup hidden
    var gp = document.getElementById('gameOverPopup');
    if (gp) { gp.style.display = 'none'; gp.setAttribute('aria-hidden','true'); }
  });

})();
</script>






<!-- Assistant Modular Wrapper inserted (fallback always) -->
<script>
(function(){
  // Disabled this wrapper because it duplicates the primary Assistant API
  // and can create fallback bubbles via extra event paths.
  return;
  var preExisting = (window.Assistant && window.Assistant.__original) ? window.Assistant.__original : window.Assistant || null;
  function createEmitter(){ var handlers = Object.create(null); return { on: function(evt, fn){ if (typeof fn !== 'function') return; (handlers[evt] || (handlers[evt]=[])).push(fn); }, off: function(evt, fn){ if (!handlers[evt]) return; if (!fn) { delete handlers[evt]; return; } handlers[evt]=handlers[evt].filter(f=>f!==fn); }, emit: function(evt){ var args = Array.prototype.slice.call(arguments,1); var list = (handlers[evt] || []).slice(); for(var i=0;i<list.length;i++){ try{ list[i].apply(null, args); }catch(e){ console.warn('assistant handler error',e);} } } }; }
  var emitter = createEmitter();
  var inProxyCall = false;
  function assistantEnabledNow(){
    try {
      if (window.assistantMuted) return false;
      if (window.enableAssistant === false) return false;
      if (document.body && document.body.classList.contains('assistant-disabled')) return false;
      if (document.documentElement && document.documentElement.classList.contains('assistant-disabled')) return false;
      return true;
    } catch(e){ return !window.assistantMuted; }
  }
  
  function ensureBubbleRoot(){
    var root = document.getElementById('assistant-bubble-root');
    if (root) return root;
    root = document.createElement('div');
    root.id = 'assistant-bubble-root';
    /* Use fixed positioning and a very high z-index to avoid being clipped by other stacking contexts */
    root.style.position = 'fixed';
    root.style.right = '20px';
    root.style.bottom = '120px';
    root.style.zIndex = '2147483647';
    root.style.pointerEvents = 'none';
    /* prevent accidental clipping */
    root.style.maxWidth = '40vw';
    root.style.display = 'block';
    document.body.appendChild(root);
    try { console.log('[Assistant][module] fallback bubble root created', root); } catch(e){}
    return root;
  }

  
  
  
  
  function showFallbackBubble(text, opts){
    opts = opts || {};
    if (!assistantEnabledNow()) return;
    try {
      // Ensure style exists
      if (!document.getElementById('assistant-fallback-style')) {
        var style = document.createElement('style');
        style.id = 'assistant-fallback-style';
        style.textContent = `
#assistant-bubble-root { position: fixed !important; right: 20px !important; bottom: 120px !important; z-index: 2147483647 !important; pointer-events: none !important; max-width: 40vw !important; display:block !important; }
.assistant-fallback-bubble {
  pointer-events: auto !important;
  max-width: 40vw !important;
  padding: 12px 14px !important;
  background: rgba(255,250,230,0.98) !important;
  color: #0b1220 !important;
  border-radius: 10px !important;
  border: 1px solid rgba(10,10,10,0.06) !important;
  box-shadow: 0 10px 30px rgba(0,0,0,0.25) !important;
  font-size: 14px !important;
  line-height: 1.35 !important;
  opacity: 0 !important;
  transition: opacity 220ms ease !important;
  position: relative !important;
  text-align: left !important;
}
.assistant-fallback-bubble.sticky {
  background: rgba(255,245,230,1) !important;
}
`;
        (document.head||document.documentElement).appendChild(style);
      }
      var root = ensureBubbleRoot();
      // clear existing content
      root.innerHTML = '';
      var b = document.createElement('div');
      b.className = 'assistant-fallback-bubble';
      if (opts.sticky) b.classList.add('sticky');
      b.setAttribute('data-debug','1');
      b.style.opacity = '0';
      b.textContent = (typeof text === 'string') ? text : (text && text.message) || JSON.stringify(text);
      // append root to documentElement to avoid body clipping
      (document.documentElement || document.body).appendChild(root);
      root.appendChild(b);
      try { console.log('[Assistant][module] fallback bubble shown', b); } catch(e){}
      // show
      requestAnimationFrame(function(){ b.style.opacity = '1'; });
      // auto-hide unless sticky
      if (!opts.sticky) {
        setTimeout(function(){
          try {
            b.style.opacity = '0';
            setTimeout(function(){ if (b.parentNode) b.parentNode.removeChild(b); }, 240);
          } catch(e){}
        }, typeof opts.timeout === 'number' ? opts.timeout : 4000);
      } else {
        // if sticky, allow click to dismiss
        b.style.cursor = 'pointer';
        b.addEventListener('click', function(){ try{ b.style.opacity='0'; setTimeout(function(){ if (b.parentNode) b.parentNode.removeChild(b); }, 180); }catch(e){} }, {passive:true});
      }
    } catch(e){ console.warn('showFallbackBubble error', e); }
  }

`;
        (document.head||document.documentElement).appendChild(style);
      }
      var root = ensureBubbleRoot();
      root.innerHTML = '';
      var b = document.createElement('div');
      b.className = 'assistant-fallback-bubble';
      b.setAttribute('data-debug','1');
      /* removed setting opacity 0 */
      b.textContent = (typeof text === 'string') ? text : (text && text.message) || JSON.stringify(text);
      // append to documentElement to avoid body clipping
      (document.documentElement || document.body).appendChild(root);
      root.appendChild(b);
      try { console.log('[Assistant][module] fallback bubble shown (persistent)', b); } catch(e){}
      // show (persistent - no auto-hide)
      requestAnimationFrame(function(){ b.style.opacity = '1'; });
      // expose a close helper on the root for debugging: click to remove
      root.addEventListener('click', function(){ try{ /* removed setting opacity 0 */ setTimeout(function(){ if (b.parentNode) b.parentNode.removeChild(b); }, 180); }catch(e){} }, {passive:true});
    } catch(e){ console.warn('showFallbackBubble error', e); }
  }

  var internal = {
    _inited: false,
    _timers: [],
    init: function(opts){
      if (this._inited) return;
      this._inited = true;
      try {
        console.log('[Assistant][module] init() preExisting=', !!preExisting);
        if (preExisting && typeof preExisting.init === 'function') {
          preExisting.init(opts);
        } else {
          var badge = document.getElementById('assist-badge') || document.querySelector('.assist-badge');
          if (badge) badge.style.display = '';
        }
        // Only use fallback bubbles when there is no pre-existing Assistant.show implementation.
        if (!preExisting || typeof preExisting.show !== 'function') {
          emitter.on('show', function(text, meta){
            try {
              showFallbackBubble(text, (meta && meta.opts) || {});
            } catch(e){ console.warn('fallback show handler error', e); }
          });
        }
      } catch(e){ console.warn('Assistant.init error', e); }
    },
    show: function(){
      if (!assistantEnabledNow()) return;
      var args = arguments;
      try {
        console.log('[Assistant][module] show() called; preExisting=', !!preExisting, 'inProxyCall=', inProxyCall, 'args=', args);
        try { emitter.emit.apply(emitter, ['show'].concat(Array.prototype.slice.call(args))); } catch(e){}
        if (preExisting && typeof preExisting.show === 'function' && !inProxyCall) {
          inProxyCall = true;
          try { preExisting.show.apply(preExisting, args); } catch(e){ console.warn('preExisting.show error', e); }
          inProxyCall = false;
        } else if (preExisting && typeof preExisting.show === 'function' && inProxyCall) {
          console.log('[Assistant][module] show() skipped proxy to avoid recursion');
        }
      } catch(e){ console.warn('Assistant.show error', e); }
    },
    emit: function(){
      if (!assistantEnabledNow()) return;
      var args = Array.prototype.slice.call(arguments);
      try { console.log('[Assistant][module] emit() called; event=', args[0], 'preExisting=', !!preExisting, 'inProxyCall=', inProxyCall, 'args=', args.slice(1)); } catch(e){}
      try { emitter.emit.apply(emitter, args); } catch(e){ console.warn('assistant local emit error', e); }
      try{
        if (preExisting && typeof preExisting.emit === 'function' && !inProxyCall){
          inProxyCall = true;
          try { preExisting.emit.apply(preExisting, args); } catch(e){ console.warn('preExisting.emit error', e); }
          inProxyCall = false;
        } else if (preExisting && typeof preExisting.emit === 'function' && inProxyCall) {
          console.log('[Assistant][module] skipping proxy emit to avoid recursion');
        }
      } catch(e){ console.warn('Assistant.emit proxy error', e); }
    },
    on: function(evt, fn){ emitter.on(evt, fn); },
    off: function(evt, fn){ emitter.off(evt, fn); },
    destroy: function(){
      if (!this._inited) return;
      this._inited = false;
      try {
        console.log('[Assistant][module] destroy() preExisting=', !!preExisting);
        try { if (preExisting && typeof preExisting.clear === 'function') preExisting.clear(); } catch(e){}
        if (preExisting && typeof preExisting.destroy === 'function') {
          preExisting.destroy();
        } else {
          var badge = document.getElementById('assist-badge') || document.querySelector('.assist-badge');
          if (badge) badge.style.display = 'none';
        }
        if (this._timers && this._timers.length) {
          this._timers.forEach(function(t){ try { clearTimeout(t); clearInterval(t); } catch(e){} });
          this._timers = [];
        }
        emitter = createEmitter();
        try { var root=document.getElementById('assistant-bubble-root'); if (root && root.parentNode) root.parentNode.removeChild(root); } catch(e){}
      } catch(e){ console.warn('Assistant.destroy error', e); }
    }
  };
  var api = {
    init: function(){ return internal.init.apply(internal, arguments); },
    show: function(){ return internal.show.apply(internal, arguments); },
    emit: function(){ return internal.emit.apply(internal, arguments); },
    on: function(){ return internal.on.apply(internal, arguments); },
    off: function(){ return internal.off.apply(internal, arguments); },
    destroy: function(){ return internal.destroy.apply(internal, arguments); },
    __original: preExisting
  };
  try { window.Assistant = api; } catch(e){ console.warn('install assistant api failed', e); }
  try {
    var enabledCheck = (typeof window.enableAssistant === 'boolean') ? window.enableAssistant : true;
    if (document.readyState !== 'loading') {
      if (enabledCheck) { api.init(); document.body.classList.remove('assistant-disabled'); }
      else { api.destroy(); document.body.classList.add('assistant-disabled'); }
    }
  } catch(e) { console.warn('assistant immediate init check failed', e); }
  document.addEventListener('DOMContentLoaded', function(){
    try {
      var enabled = (typeof window.enableAssistant === 'boolean') ? window.enableAssistant : true;
      if (enabled) { api.init(); document.body.classList.remove('assistant-disabled'); }
      else { api.destroy(); document.body.classList.add('assistant-disabled'); }
    } catch(e) {}
  });
})();
</script>






<!-- Assistant fallback shim inserted -->
<script>
(function(){
  // Disabled: fallback shim was duplicating bubbles and conflicting with primary assistant UI.
  return;
  function tryAttach(){
    try{
      // If showFallbackBubble exists, wrap known APIs to ensure bubble shows
      if (typeof showFallbackBubble !== 'function') return false;
      var patched = false;
      // Patch global Assistant object if present
      var g = window.Assistant || window.assistant || window.AssistantAPI || window.assistantAPI;
      if (g && typeof g.show === 'function' && !g.__showPatched){
        var orig = g.show.bind(g);
        g.show = function(){
          try { showFallbackBubble(arguments[0], arguments[1]||{}); } catch(e){}
          return orig.apply(null, arguments);
        };
        g.__showPatched = true;
        console.log('[AssistantPatch] wrapped global show()');
        patched = true;
      }
      // If there's an emitter-style API with 'on', try to register
      var em = (window.assistantEmitter || (g && g.emitter) || window.emitter);
      if (em && typeof em.on === 'function' && !em.__onPatched){
        try {
          em.on('show', function(t,m){ try { showFallbackBubble(t,m||{}); } catch(e){} });
          em.__onPatched = true;
          console.log('[AssistantPatch] attached to emitter.on(show)');
          patched = true;
        } catch(e){}
      }
      return patched;
    }catch(e){ return false; }
  }
  var tries = 0;
  var id = setInterval(function(){
    var ok = tryAttach();
    tries++;
    if (ok || tries>40) clearInterval(id);
  }, 200);
})();
</script>
<!-- End Assistant fallback shim -->


<!-- Assistant debug overlay shim -->
<script>
(function(){
  // Disabled: debug overlay shim patched showFallbackBubble and produced extra debug bubbles.
  return;
  function debugEnsure(){
    var root = document.getElementById('assistant-bubble-root');
    if (!root){
      root = document.createElement('div');
      root.id = 'assistant-bubble-root';
      document.documentElement.appendChild(root);
    }
    // strong, visible styles
    root.style.position = 'fixed';
    root.style.left = '50%';
    root.style.top = '12%';
    root.style.transform = 'translateX(-50%)';
    root.style.zIndex = '9999999999';
    root.style.pointerEvents = 'auto'; // allow clicks
    root.style.display = 'block';
    return root;
  }

  function debugShow(text, opts){
    try{
      var root = debugEnsure();
      root.innerHTML = '';
      var b = document.createElement('div');
      b.className = 'assistant-fallback-bubble';
      b.style.background = 'rgba(255,0,50,0.95)';
      b.style.color = '#fff';
      b.style.padding = '16px 20px';
      b.style.borderRadius = '12px';
      b.style.fontSize = '18px';
      b.style.boxShadow = '0 18px 50px rgba(0,0,0,0.6)';
      b.style.maxWidth = '70vw';
      b.style.textAlign = 'center';
      b.style.opacity = '1';
      b.textContent = (typeof text === 'string') ? text : (text && text.message) || JSON.stringify(text);
      root.appendChild(b);
      // log computed style & rect
      try {
        var cs = window.getComputedStyle(b);
        console.log('[AssistantDebug] bubble computed style:', {visibility: cs.visibility, display: cs.display, opacity: cs.opacity, zIndex: cs.zIndex});
      } catch(e){ console.warn(e); }
      try {
        var r = b.getBoundingClientRect();
        console.log('[AssistantDebug] bubble rect:', r);
      } catch(e){ console.warn(e); }
      // attach click to remove
      b.addEventListener('click', function(){ if (b.parentNode) b.parentNode.removeChild(b); }, {passive:true});
      return b;
    }catch(e){
      console.warn('debugShow error', e);
    }
  }

  // Expose to window for manual test
  window.__assistant_debug_show = debugShow;
  window.addEventListener('keydown', function(e){
    if (e.key === 'b') debugShow('DEBUG: visible test bubble — press to dismiss');
  });

  // Patch existing showFallbackBubble if present
  if (typeof showFallbackBubble === 'function'){
    var orig = showFallbackBubble;
    window.showFallbackBubble = function(text, opts){
      try{ debugShow(text, opts); }catch(e){}
      try{ return orig(text, opts); }catch(e){}
    };
    console.log('[AssistantDebug] patched showFallbackBubble to also show debug bubble');
  } else {
    // create a small poll to patch later
    var tries = 0;
    var id = setInterval(function(){
      if (typeof showFallbackBubble === 'function'){
        clearInterval(id);
        var orig = showFallbackBubble;
        window.showFallbackBubble = function(text, opts){
          try{ debugShow(text, opts); }catch(e){};
          try{ return orig(text, opts); }catch(e){};
        };
        console.log('[AssistantDebug] patched late showFallbackBubble');
      }
      tries++; if (tries>30) clearInterval(id);
    }, 200);
  }
})();
</script>
<!-- End Assistant debug overlay shim -->

</body>

</html>
